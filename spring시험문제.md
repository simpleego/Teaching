물론이죠! 아래는 스프링 프레임워크 프로젝트 수행 능력을 평가하기 위한 15문제의 4지선다형 퀴즈입니다. 각 문항은 마크다운 형식으로 구성되어 있으며, 정답은 마지막에 한꺼번에 정리해두었습니다. 난이도는 초급, 중급, 고급으로 균형 있게 배분했습니다.

---

# 🧪 Spring Framework 평가 퀴즈 (4지선다형)

## 🔰 초급 (1~5번)

**1. Spring Framework에서 의존성 주입(Dependency Injection)의 주요 목적은 무엇인가요?**  
- A. 객체 간의 결합도를 낮추기 위해  
- B. 애플리케이션 속도를 높이기 위해  
- C. 데이터베이스 연결을 단순화하기 위해  
- D. 보안을 강화하기 위해  

**2. @Autowired 애노테이션의 역할은 무엇인가요?**  
- A. 클래스를 자동으로 실행한다  
- B. 메서드를 비동기로 실행한다  
- C. 빈을 자동으로 주입한다  
- D. 예외를 자동으로 처리한다  

**3. Spring MVC에서 Controller 클래스는 어떤 역할을 하나요?**  
- A. 클라이언트 요청을 처리하고 응답을 반환한다  
- B. 뷰를 렌더링한다  
- C. 보안 설정을 담당한다  
- D. 데이터베이스와 직접 통신한다  

**4. Spring Boot의 주요 장점 중 하나는 무엇인가요?**  
- A. 자동 설정과 내장 서버를 제공한다  
- B. 모든 설정을 수동으로 해야 한다  
- C. 복잡한 XML 설정을 요구한다  
- D. JSP만 지원한다  

**5. Spring에서 Bean의 생명주기를 관리하는 객체는 무엇인가요?**  
- A. JDBC Driver  
- B. ApplicationContext  
- C. EntityManager  
- D. HttpServletRequest  

---

## ⚙️ 중급 (6~10번)

**6. @RestController 애노테이션은 어떤 기능을 제공하나요?**  
- A. 서버를 시작한다  
- B. 파일을 다운로드한다  
- C. JSON 또는 XML 데이터를 반환한다  
- D. HTML 페이지를 반환한다  

**7. Spring Security의 주요 목적은 무엇인가요?**  
- A. 뷰를 렌더링하기 위해  
- B. 애플리케이션의 보안을 제공하기 위해  
- C. 데이터베이스 연결을 단순화하기 위해  
- D. 서버를 자동으로 시작하기 위해  

**8. Spring에서 @Transactional 애노테이션은 어떤 기능을 하나요?**  
- A. 트랜잭션을 자동으로 관리한다  
- B. 뷰를 렌더링한다  
- C. 데이터를 암호화한다  
- D. 파일을 업로드한다  

**9. Spring Boot에서 application.properties 파일의 역할은 무엇인가요?**  
- A. 애플리케이션 설정 값을 정의한다  
- B. HTML 템플릿을 정의한다  
- C. 보안 정책을 설정한다  
- D. 데이터베이스 테이블을 생성한다  

**10. Spring에서 Repository 인터페이스는 어떤 계층에 속하나요?**  
- A. 프레젠테이션 계층  
- B. 보안 계층  
- C. 비즈니스 계층  
- D. 데이터 접근 계층  

---

## 🧠 고급 (11~15번)

**11. Spring Boot에서 내장된 웹 서버는 무엇인가요?**  
- A. Jetty  
- B. Tomcat  
- C. Apache  
- D. Nginx  

**12. Spring에서 AOP(Aspect-Oriented Programming)의 주요 목적은 무엇인가요?**  
- A. 공통 관심사를 모듈화하기 위해  
- B. 뷰를 렌더링하기 위해  
- C. 서버를 자동으로 시작하기 위해  
- D. 데이터베이스 연결을 단순화하기 위해  

**13. Spring에서 @Component 애노테이션은 어떤 역할을 하나요?**  
- A. 보안 설정을 적용한다  
- B. 클래스를 빈으로 등록한다  
- C. 데이터베이스 연결을 설정한다  
- D. 서버를 시작한다  

**14. Spring Boot에서 DevTools의 주요 기능은 무엇인가요?**  
- A. 자동 리스타트 및 핫 스왑  
- B. 데이터 암호화  
- C. 보안 강화  
- D. 서버 부하 분산  

**15. Spring에서 Bean의 기본 스코프는 무엇인가요?**  
- A. prototype  
- B. session  
- C. singleton  
- D. request  

---

## ✅ 정답 정리

| 번호 | 정답 |
|------|------|
| 1    | A    |
| 2    | C    |
| 3    | A    |
| 4    | A    |
| 5    | B    |
| 6    | C    |
| 7    | B    |
| 8    | A    |
| 9    | A    |
| 10   | D    |
| 11   | B    |
| 12   | A    |
| 13   | B    |
| 14   | A    |
| 15   | C    |

---

다음은 서블릿, 스프링 프레임워크, 스프링 부트에 대한 이론 평가 문제입니다.

***

### **서블릿 & 스프링 프레임워크 이론 평가 문제**

**1. 서블릿(Servlet)의 생명주기(Lifecycle) 메서드로 올바르게 짝지어진 것은 무엇인가요?**
    A. `init() -> service() -> destroy()`
    B. `start() -> run() -> stop()`
    C. `constructor() -> handler() -> close()`
    D. `init() -> doPost() -> destroy()`

---

**2. HTTP GET 요청과 POST 요청의 주된 차이점으로 가장 적절하지 않은 것은 무엇인가요?**
    A. GET 요청은 URL에 데이터가 포함되지만, POST 요청은 메시지 바디에 데이터가 포함된다.
    B. GET 요청은 멱등성(idempotent)을 가지지만, POST 요청은 그렇지 않다.
    C. GET 요청은 브라우저 기록에 남지만, POST 요청은 남지 않는다.
    D. GET 요청은 항상 POST 요청보다 처리 속도가 빠르다.

---

**3. 웹 애플리케이션의 모든 서블릿이 공유하는 정보를 저장하는 데 가장 적합한 객체는 무엇인가요?**
    A. ServletContext
    B. ServletConfig
    C. HttpSession
    D. HttpServletRequest

---

**4. 서블릿(Servlet)의 스레드 안전성(Thread Safety)에 대한 설명으로 가장 올바른 것은?**
    A. 서블릿 컨테이너는 각 요청마다 새로운 서블릿 인스턴스를 생성하므로 스레드 안전성이 보장된다.
    B. 서블릿의 멤버 변수(인스턴스 변수)는 여러 스레드에 의해 공유될 수 있어 동시성 문제가 발생할 수 있다.
    C. 모든 지역 변수는 스레드 간에 공유되므로 동기화(synchronized) 처리가 필수적이다.
    D. doGet()과 doPost() 메서드는 기본적으로 동기화되어 있어 스레드 안전하다.

---

**5. 스프링 프레임워크의 핵심 원칙 중 하나인 '제어의 역전(Inversion of Control)'을 가장 잘 설명한 것은 무엇인가요?**
    A. 개발자가 직접 객체를 생성하고 의존성을 설정하는 방식이다.
    B. 객체의 생성과 생명주기 관리를 개발자가 아닌 프레임워크(컨테이너)가 대신 해주는 것이다.
    C. 상속(Inheritance)을 통해 상위 클래스의 기능을 재사용하는 디자인 패턴이다.
    D. 데이터베이스와의 연결을 설정하고 관리하는 기술이다.

---

**6. 스프링의 의존성 주입(Dependency Injection) 방법이 아닌 것은 무엇인가요?**
    A. 생성자 주입 (Constructor Injection)
    B. 수정자 주입 (Setter Injection)
    C. 필드 주입 (Field Injection)
    D. 상속 주입 (Inheritance Injection)

---

**7. 스프링에서 빈(Bean)의 스코프(Scope) 중, 요청(주입)이 발생할 때마다 새로운 빈 인스턴스를 생성하는 것은 무엇인가요?**
    A. singleton
    B. prototype
    C. request
    D. session

---

**8. 스프링 AOP(Aspect-Oriented Programming)의 핵심 용어에 대한 설명으로 틀린 것은?**
    A. Advice: 특정 JoinPoint에서 수행될 '무엇'을 의미하며, 즉 부가기능 로직 자체를 의미한다.
    B. JoinPoint: Advice가 적용될 수 있는 모든 위치나 시점을 의미한다.
    C. Pointcut: 여러 JoinPoint 중에서 실제로 Advice를 적용할 대상을 선별하는 표현식이다.
    D. Weaving: Pointcut을 통해 비즈니스 로직에서 공통 관심 사항을 분리하는 과정이다.

---

**9. 스프링 프레임워크의 DispatcherServlet에 대한 설명으로 가장 적절한 것은?**
    A. 데이터베이스 커넥션 풀을 관리하는 역할을 한다.
    B. Front Controller 패턴을 구현하여 모든 클라이언트의 요청을 가장 먼저 받아 적절한 컨트롤러에 위임한다.
    C. 스프링 빈(Bean)의 생명주기를 관리하는 IoC 컨테이너이다.
    D. JSP나 Thymeleaf와 같은 뷰(View)를 직접 렌더링하는 템플릿 엔진이다.

---

**10. 개발자가 직접 정의한 클래스를 스프링 빈으로 등록할 때 사용하는 어노테이션이 아닌 것은?**
    A. @Component
    B. @Controller
    C. @Autowired
    D. @Service

---

**11. 스프링에서 @Bean과 @Component 어노테이션의 차이점으로 올바른 것은?**
    A. @Bean은 메서드 레벨, @Component는 클래스 레벨에 적용된다.
    B. @Component는 싱글톤 스코프만 가능하지만, @Bean은 다양한 스코프를 지정할 수 있다.
    C. @Bean은 의존성 주입이 불가능하지만, @Component는 가능하다.
    D. @Component는 XML 설정에서만, @Bean은 Java 기반 설정에서만 사용 가능하다.

---

**12. 스프링 부트(Spring Boot)의 가장 큰 장점으로 꼽히는 것은 무엇인가요?**
    A. 복잡한 XML 기반의 설정을 통해 개발자에게 높은 자유도를 제공한다.
    B. 의존성 자동 관리를 통해 버전 충돌 문제를 완전히 해결했다.
    C. 자동 설정(Auto-configuration)과 내장 WAS를 통해 빠르고 간편하게 독립 실행 가능한 애플리케이션을 만들 수 있다.
    D. 모든 종류의 데이터베이스를 별도 설정 없이 즉시 사용할 수 있다.

---

**13. 스프링 부트의 '스타터(Starter)' 의존성에 대한 설명으로 가장 올바른 것은?**
    A. 프로젝트의 시작점 역할을 하는 main 메서드를 자동으로 생성해준다.
    B. 특정 기능을 개발하는 데 필요한 의존성들의 묶음(set)으로, 버전 관리를 편리하게 해준다.
    C. 애플리케이션의 성능을 모니터링하는 액추에이터(Actuator) 기능을 활성화한다.
    D. 애플리케이션이 실행될 때 초기 데이터를 데이터베이스에 자동으로 삽입하는 기능이다.

---

**14. 스프링 부트 애플리케이션의 메인 클래스에 주로 사용되는 @SpringBootApplication 어노테이션이 포함하지 않는 기능은 무엇인가요?**
    A. @SpringBootConfiguration
    B. @EnableAutoConfiguration
    C. @ComponentScan
    D. @EnableWebMvc

---

**15. 스프링 부트에서 `application.properties` 또는 `application.yml` 파일의 주된 용도는 무엇인가요?**
    A. 애플리케이션에서 사용할 모든 의존성 라이브러리를 명시한다.
    B. 자바 소스 코드를 작성하고 애플리케이션의 비즈니스 로직을 구현한다.
    C. 서버 포트, 데이터베이스 연결 정보 등 애플리케이션의 각종 설정을 정의한다.
    D. SQL 쿼리문을 별도로 저장하고 관리한다.

---

**16. 스프링 부트 액추에이터(Actuator)가 제공하는 기능이 아닌 것은?**
    A. 애플리케이션의 상태(health)를 체크하는 엔드포인트 제공
    B. 애플리케이션에 등록된 모든 빈(Bean) 목록을 확인하는 엔드포인트 제공
    C. 애플리케이션의 비즈니스 로직 성능을 프로파일링하고 분석
    D. 환경 변수(Environment variables), 시스템 속성 등 설정 정보를 확인하는 엔드포인트 제공

---

**17. JSP(JavaServer Pages)와 서블릿(Servlet)의 관계에 대한 설명으로 가장 올바른 것은?**
    A. JSP와 서블릿은 완전히 다른 기술이며 서로 변환될 수 없다.
    B. 서블릿은 뷰(View)를, JSP는 컨트롤러(Controller) 로직을 처리하는 데 특화되어 있다.
    C. JSP는 내부적으로 서블릿으로 변환되어 실행되며, HTML 기반의 뷰 작업에 더 용이하다.
    D. 서블릿은 항상 JSP보다 먼저 실행되어야 한다.

---

**18. 스프링 프레임워크에서 PSA(Portable Service Abstraction)의 개념을 가장 잘 설명하는 예시는?**
    A. AOP를 이용하여 로깅이나 트랜잭션과 같은 부가 기능을 비즈니스 로직과 분리하는 것
    B. 어떤 종류의 데이터베이스를 사용하든 일관된 방식으로 예외를 처리할 수 있도록 DataAccessException을 제공하는 것
    C. DI(의존성 주입)를 통해 객체 간의 결합도를 낮추고 유연한 설계를 가능하게 하는 것
    D. Front Controller인 DispatcherServlet이 모든 요청을 받아 처리하는 것

---

**19. 스프링 부트의 자동 설정(Auto-configuration)이 동작하는 핵심 원리는 무엇인가요?**
    A. 개발자가 작성한 모든 클래스를 분석하여 필요한 빈을 자동으로 생성한다.
    B. 클래스패스(Classpath)에 특정 라이브러리가 존재할 경우, 그와 관련된 빈들을 조건부로 자동 등록한다.
    C. pom.xml 또는 build.gradle에 명시된 모든 의존성을 빈으로 등록한다.
    D. application.properties 파일에 'spring.autoconfigure.enabled=true'가 있어야만 동작한다.

---

**20. 전통적인 서블릿 기반 웹 애플리케이션과 스프링 부트 기반 웹 애플리케이션의 가장 큰 구조적 차이점은 무엇인가요?**
    A. 서블릿 기반은 외부 WAS에 WAR 파일을 배포해야 하지만, 스프링 부트는 내장 WAS를 포함한 JAR 파일로 단독 실행이 가능하다.
    B. 서블릿은 멀티 스레드 환경에서 동작하지만, 스프링 부트는 싱글 스레드 환경에서만 동작한다.
    C. 서블릿 기반 애플리케이션은 web.xml 파일이 필수적이지만, 스프링 부트는 설정 파일이 전혀 필요 없다.
    D. 서블릿은 MVC 패턴을 사용할 수 없지만, 스프링 부트는 MVC 패턴을 강제한다.

***

### **정답 및 해설**

1.  **A** : 서블릿 컨테이너는 서블릿 인스턴스 생성 후 `init()`, 각 요청 처리를 위해 `service()`, 인스턴스 소멸 전 `destroy()`를 순서대로 호출합니다.
2.  **D** : 처리 속도는 다양한 요인에 따라 달라지므로, GET이 항상 POST보다 빠르다고 단정할 수 없습니다.
3.  **A** : `ServletContext`는 웹 애플리케이션 전역에서 모든 서블릿이 공유하는 데이터를 저장하는 데 사용됩니다.
4.  **B** : 서블릿은 싱글톤으로 관리되므로, 상태를 가지는 멤버 변수는 여러 스레드에 의해 공유되어 동시성 문제를 유발할 수 있습니다.
5.  **B** : IoC(제어의 역전)는 객체의 생성, 관리, 의존성 설정에 대한 제어권이 개발자가 아닌 프레임워크(컨테이너)에 있는 것을 의미합니다.
6.  **D** : '상속 주입'은 스프링에서 공식적으로 지원하는 의존성 주입 패턴이 아닙니다.
7.  **B** : `prototype` 스코프는 빈이 요청(주입)될 때마다 항상 새로운 인스턴스를 생성하여 반환합니다.
8.  **D** : Weaving은 분리된 Advice를 Pointcut에 따라 실제 타겟 객체의 JoinPoint에 '적용'하여 프록시 객체를 만드는 과정, 즉 합치는 과정입니다.
9.  **B** : `DispatcherServlet`은 Front Controller 패턴의 구현체로, 모든 웹 요청을 단일 진입점에서 수신하여 적절한 핸들러(컨트롤러)에게 전달하는 중앙 제어 역할을 합니다.
10. **C** : `@Autowired`는 등록된 빈을 다른 빈에 '주입'할 때 사용하는 어노테이션이며, 클래스를 빈으로 '등록'하는 기능은 없습니다.
11. **A** : `@Component`는 클래스에, `@Bean`은 메서드에 적용하여 각각 클래스 자체 또는 메서드가 반환하는 객체를 빈으로 등록합니다.
12. **C** : 스프링 부트의 핵심은 자동 설정, 스타터 의존성, 내장 서버 등을 통해 개발자가 최소한의 설정만으로 빠르게 독립 실행 가능한 애플리케이션을 개발하도록 지원하는 것입니다.
13. **B** : 스타터는 특정 기능 구현에 필요한 라이브러리 의존성들의 묶음으로, `pom.xml`이나 `build.gradle`에 한 줄만 추가하면 관련 라이브러리들이 모두 포함되어 관리가 용이합니다.
14. **D** : `@EnableWebMvc`는 스프링 MVC의 세부 설정을 직접 제어하고 싶을 때 사용하며, 보통은 `@SpringBootApplication`의 자동 설정에 맡깁니다.
15. **C** : 이 파일들은 애플리케이션의 포트 번호, 데이터베이스 접속 정보, 로깅 레벨 등 다양한 외부 설정을 정의하여 코드 수정 없이 애플리케이션의 동작을 변경할 수 있게 합니다.
16. **C** : 액추에이터는 애플리케이션의 상태, 정보, 메트릭 등 '운영'에 초점을 맞춘 정보를 제공하며, 상세한 비즈니스 로직 성능 분석은 APM 툴의 영역입니다.
17. **C** : JSP는 HTML 코드 작성이 용이하도록 설계되었으며, WAS는 JSP 파일을 서블릿 자바 코드로 변환하여 컴파일 및 실행합니다.
18. **B** : PSA(일관된 서비스 추상화)는 특정 기술에 종속되지 않는 일관된 인터페이스를 제공하는 것을 의미합니다. 데이터베이스 기술이 바뀌어도 스프링의 `DataAccessException`으로 예외를 처리할 수 있는 것이 대표적인 예입니다.
19. **B** : 스프링 부트는 `@ConditionalOnClass`와 같은 조건부 어노테이션을 사용하여, 클래스패스에 특정 라이브러리가 존재할 때만 관련 설정을 자동으로 활성화합니다.
20. **A** : 가장 큰 구조적 차이는 배포 및 실행 방식입니다. 스프링 부트는 Tomcat 같은 WAS를 내장하여 `java -jar` 명령어로 간편하게 실행할 수 있는 독립적인 애플리케이션을 만듭니다.
