# 콜백과Ref 비유
> `useCallback`과 `useRef`를 우리에게 익숙한 현실 속 비유로 쉽게 설명

### `useCallback` ☕️ 커피숍의 단골 레시피

`useCallback`은 **한번 만들어 둔 '단골 레시피'**와 같습니다.

* **상황:** 당신이 커피숍 사장이고, '바닐라 라떼'를 만드는 특별한 레시피(함수)가 있다고 상상해 보세요.
* **`useCallback` 미사용:** 아르바이트생(자식 컴포넌트)에게 손님이 올 때마다 **매번 A4용지에 레시피를 새로 적어서** 줍니다. 레시피 내용은 똑같은데도 말이죠. 아르바이트생은 "어? 이거 아까 받은 거랑 똑같은데, 일단 새로운 레시피네?"라고 생각하며 매번 레시피를 새로 익히느라 불필요한 에너지를 씁니다.
* **`useCallback` 사용:** 똑똑한 당신은 '바닐라 라떼' 레시피를 **코팅해서 딱 하나만 만들어 둡니다 (`useCallback`)**. 그리고 아르바이트생에게는 계속 그 코팅된 레시피를 참조하라고 알려줍니다. 아르바이트생은 "아, 늘 보던 그 레시피구나!"하고 바로 커피를 만들 수 있죠.

**핵심 비유:**
* **함수:** 커피 레시피
* **컴포넌트 렌더링:** 손님이 새로 오는 것
* **`useCallback`:** 내용을 코팅해서 **재활용**하는 레시피 📜
* **의존성 배열(`deps`):** 레시피에 들어가는 **핵심 재료**(예: 바닐라 시럽). 만약 이 시럽이 다른 종류로 바뀐다면, 그때는 어쩔 수 없이 레시피를 새로 만들어야 합니다.

결론적으로 **`useCallback`은 함수의 내용이 바뀌지 않았다면, 렌더링이 계속 일어나도 이전에 만들었던 함수를 그대로 재사용**하게 해주는 기술입니다.

---

### `useRef` 📌 개인 메모 보드

`useRef`는 컴포넌트가 가지고 있는 **지워지지 않는 '개인 메모 보드'나 '이름표'**와 같습니다.

* **상황:** 당신이 어떤 작업을 하는 동안, 계속 기억해야 할 정보나 가리켜야 할 대상이 있다고 상상해 보세요.
* **`useState`와의 차이점:** `useState`는 메모 보드에 무언가 적을 때마다 "여러분! 제가 메모를 바꿨어요!"라고 **모두에게 외치는 것**과 같습니다. 이 외침 때문에 모두가 하던 일을 멈추고 주목하게 되죠(리렌더링).
* **`useRef`의 역할:** `useRef`는 그냥 **조용히 내 개인 메모 보드에 썼다 지웠다** 하는 것과 같습니다. 내가 뭘 적든 다른 사람들은 신경 쓰지 않고 자기 일을 계속합니다(리렌더링 없음). 이 메모 보드는 내가 자리를 떠나지 않는 한(컴포넌트가 사라지기 전까지) 계속 그 자리에 있죠.

**핵심 비유:**
* **`useRef` 자체:** 개인 메모 보드 📋
* **`useRef`의 `.current` 속성:** 보드에 붙어있는 **포스트잇 메모**
* **값 변경:** 포스트잇의 내용을 바꾸는 행위

**두 가지 주된 용도:**
1.  **값 저장용:** 렌더링을 일으키지 않으면서 어떤 값을 계속 기억하고 싶을 때 사용합니다. (예: "지금까지 버튼을 몇 번 눌렀지?" 같은 횟수를 조용히 기록)
2.  **DOM 요소 지목용:** "저기 세 번째 의자!"처럼 특정 DOM 요소를 직접 가리키는 **이름표** 역할도 합니다. `document.getElementById()`처럼 특정 태그에 직접 접근하고 싶을 때 사용합니다.

결론적으로 **`useRef`는 리렌더링을 발생시키지 않고 무언가를 기억하거나, 특정 대상을 직접 가리키고 싶을 때 사용하는 보관함**입니다.

#  또다른 비유 설명
좋아, jong! 리액트의 `useCallback`과 `useRef`는 처음 보면 헷갈릴 수 있지만, 현실적인 비유로 풀어보면 훨씬 쉽게 이해돼. 아래에 각각을 익숙한 상황에 빗대어 설명해볼게:

---

### 🧠 `useCallback` — "메뉴판에 적힌 요리법"

**비유:**  
레스토랑에서 셰프가 자주 만드는 요리가 있다고 해보자. 매번 요리법을 새로 적는 대신, 메뉴판에 요리법을 적어두고 그대로 따라 만든다. 이렇게 하면 시간도 절약되고 실수도 줄어들지.

**리액트에서:**  
컴포넌트가 리렌더링될 때마다 함수가 새로 만들어지면 성능에 영향을 줄 수 있어. `useCallback`은 함수(요리법)를 기억해두고, 의존성이 바뀌지 않으면 같은 함수를 계속 사용해. 즉, "요리법을 다시 쓰지 않고 메뉴판에 있는 걸 그대로 쓰는 것"이야.

---

### 📦 `useRef` — "서랍 속 메모지"

**비유:**  
책상에 서랍이 하나 있고, 거기에 메모지를 넣어두었다고 해보자. 메모지에는 중요한 정보(예: 전화번호나 비밀번호)가 적혀 있고, 필요할 때 꺼내서 확인하지만, 메모지를 꺼낸다고 책상이 바뀌진 않아.

**리액트에서:**  
`useRef`는 컴포넌트가 리렌더링되더라도 바뀌지 않는 값을 저장할 수 있어. DOM 요소를 직접 참조하거나, 이전 값을 기억하거나, 어떤 상태를 저장할 때 쓰이지. 컴포넌트가 다시 그려져도 `useRef`에 저장된 값은 그대로 유지돼 — 마치 서랍 속 메모지가 그대로 있는 것처럼.

---

### 요약 비교

| Hook        | 현실 비유             | 목적                           |
|-------------|------------------------|--------------------------------|
| `useCallback` | 메뉴판에 적힌 요리법   | 함수를 기억해서 재생성 방지       |
| `useRef`     | 서랍 속 메모지         | 리렌더링과 무관한 값 저장/참조   |

---

혹시 `useMemo`도 같이 궁금해? 그것도 비슷한 방식으로 설명해줄 수 있어!
