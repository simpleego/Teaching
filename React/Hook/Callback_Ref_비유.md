# 콜백과Ref 비유
> `useCallback`과 `useRef`를 우리에게 익숙한 현실 속 비유로 쉽게 설명

### `useCallback` ☕️ 커피숍의 단골 레시피

`useCallback`은 **한번 만들어 둔 '단골 레시피'**와 같습니다.

* **상황:** 당신이 커피숍 사장이고, '바닐라 라떼'를 만드는 특별한 레시피(함수)가 있다고 상상해 보세요.
* **`useCallback` 미사용:** 아르바이트생(자식 컴포넌트)에게 손님이 올 때마다 **매번 A4용지에 레시피를 새로 적어서** 줍니다. 레시피 내용은 똑같은데도 말이죠. 아르바이트생은 "어? 이거 아까 받은 거랑 똑같은데, 일단 새로운 레시피네?"라고 생각하며 매번 레시피를 새로 익히느라 불필요한 에너지를 씁니다.
* **`useCallback` 사용:** 똑똑한 당신은 '바닐라 라떼' 레시피를 **코팅해서 딱 하나만 만들어 둡니다 (`useCallback`)**. 그리고 아르바이트생에게는 계속 그 코팅된 레시피를 참조하라고 알려줍니다. 아르바이트생은 "아, 늘 보던 그 레시피구나!"하고 바로 커피를 만들 수 있죠.

**핵심 비유:**
* **함수:** 커피 레시피
* **컴포넌트 렌더링:** 손님이 새로 오는 것
* **`useCallback`:** 내용을 코팅해서 **재활용**하는 레시피 📜
* **의존성 배열(`deps`):** 레시피에 들어가는 **핵심 재료**(예: 바닐라 시럽). 만약 이 시럽이 다른 종류로 바뀐다면, 그때는 어쩔 수 없이 레시피를 새로 만들어야 합니다.

결론적으로 **`useCallback`은 함수의 내용이 바뀌지 않았다면, 렌더링이 계속 일어나도 이전에 만들었던 함수를 그대로 재사용**하게 해주는 기술입니다.

---

### `useRef` 📌 개인 메모 보드

`useRef`는 컴포넌트가 가지고 있는 **지워지지 않는 '개인 메모 보드'나 '이름표'**와 같습니다.

* **상황:** 당신이 어떤 작업을 하는 동안, 계속 기억해야 할 정보나 가리켜야 할 대상이 있다고 상상해 보세요.
* **`useState`와의 차이점:** `useState`는 메모 보드에 무언가 적을 때마다 "여러분! 제가 메모를 바꿨어요!"라고 **모두에게 외치는 것**과 같습니다. 이 외침 때문에 모두가 하던 일을 멈추고 주목하게 되죠(리렌더링).
* **`useRef`의 역할:** `useRef`는 그냥 **조용히 내 개인 메모 보드에 썼다 지웠다** 하는 것과 같습니다. 내가 뭘 적든 다른 사람들은 신경 쓰지 않고 자기 일을 계속합니다(리렌더링 없음). 이 메모 보드는 내가 자리를 떠나지 않는 한(컴포넌트가 사라지기 전까지) 계속 그 자리에 있죠.

**핵심 비유:**
* **`useRef` 자체:** 개인 메모 보드 📋
* **`useRef`의 `.current` 속성:** 보드에 붙어있는 **포스트잇 메모**
* **값 변경:** 포스트잇의 내용을 바꾸는 행위

**두 가지 주된 용도:**
1.  **값 저장용:** 렌더링을 일으키지 않으면서 어떤 값을 계속 기억하고 싶을 때 사용합니다. (예: "지금까지 버튼을 몇 번 눌렀지?" 같은 횟수를 조용히 기록)
2.  **DOM 요소 지목용:** "저기 세 번째 의자!"처럼 특정 DOM 요소를 직접 가리키는 **이름표** 역할도 합니다. `document.getElementById()`처럼 특정 태그에 직접 접근하고 싶을 때 사용합니다.

결론적으로 **`useRef`는 리렌더링을 발생시키지 않고 무언가를 기억하거나, 특정 대상을 직접 가리키고 싶을 때 사용하는 보관함**입니다.
