
# 성적처리

오오, 튼튼한젤리7889님! 리액트로 성적 관리 프로그램이라니, 이거 완전 실용적이고 힙한 아이디어인데? 🤩 `useState`, `useEffect`에 `useMemo`까지 야무지게 써서 딱 만들어 줄게!

일단 코드는 아래처럼 짜봤어. 설명도 곁들여줄게!

```jsx
import React, { useState, useEffect, useMemo, useCallback } from 'react';

// 학점 계산 함수 (유틸리티)
const calculateGrade = (average) => {
  if (average >= 90) return 'A';
  if (average >= 80) return 'B';
  if (average >= 70) return 'C';
  if (average >= 60) return 'D';
  return 'F';
};

// 표준편차 계산 함수 (시간이 많이 걸린다고 가정)
const calculateStandardDeviation = (scores) => {
  if (scores.length === 0) return 0;
  const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;
  const variance = scores.reduce((sum, score) => sum + Math.pow(score - mean, 2), 0) / scores.length;
  // 계산이 복잡하고 오래 걸린다고 가정하기 위해 일부러 지연 추가 (실제 사용 시에는 제거)
  let start = performance.now();
  while (performance.now() - start < 100) { /* do nothing for 100ms */ }
  return Math.sqrt(variance);
};

function GradeCalculator() {
  // 초기 학생 데이터 (5명)
  const initialStudents = useMemo(() => ([
    { id: 1, name: '학생1', korean: 0, english: 0, math: 0 },
    { id: 2, name: '학생2', korean: 0, english: 0, math: 0 },
    { id: 3, name: '학생3', korean: 0, english: 0, math: 0 },
    { id: 4, name: '학생4', korean: 0, english: 0, math: 0 },
    { id: 5, name: '학생5', korean: 0, english: 0, math: 0 },
  ]), []);

  const [students, setStudents] = useState(initialStudents);

  // 성적 입력 변경 핸들러
  // useCallback을 사용하여 불필요한 재생성 방지
  const handleScoreChange = useCallback((id, subject, value) => {
    // 숫자로 변환하고, 0~100 범위로 제한
    const score = Math.max(0, Math.min(100, Number(value)));

    setStudents(prevStudents =>
      prevStudents.map(student =>
        student.id === id ? { ...student, [subject]: score } : student
      )
    );
  }, []); // 의존성 배열이 비어있으므로 컴포넌트 마운트 시 한 번만 생성

  // 각 학생의 총점, 평균, 학점을 계산 (실시간 반영)
  const calculatedStudents = useMemo(() => {
    return students.map(student => {
      const total = student.korean + student.english + student.math;
      const average = total / 3;
      const grade = calculateGrade(average);
      return { ...student, total, average, grade };
    });
  }, [students]); // students 배열이 변경될 때만 다시 계산

  // 등수 및 표준편차 계산 (useMemo 사용, 시간이 많이 걸린다고 가정)
  // 등수는 총점을 기준으로, 표준편차는 모든 학생의 평균 점수를 기준으로 계산
  const { rankedStudents, stdDev } = useMemo(() => {
    // 1. 등수 계산
    const sortedStudents = [...calculatedStudents].sort((a, b) => b.total - a.total); // 총점 내림차순 정렬
    const studentsWithRank = sortedStudents.map((student, index, arr) => {
      // 동점자 처리
      const prevStudent = arr[index - 1];
      if (prevStudent && student.total === prevStudent.total) {
        return { ...student, rank: prevStudent.rank };
      }
      return { ...student, rank: index + 1 };
    });

    // 원래 순서대로 정렬 (옵션) 또는 정렬된 순서 그대로 사용 가능
    // 여기서는 원래 id 순서로 보여주기 위해 다시 정렬
    const finalRankedStudents = studentsWithRank.sort((a, b) => a.id - b.id);

    // 2. 표준편차 계산
    const allAverages = calculatedStudents.map(s => s.average);
    const standardDeviation = calculateStandardDeviation(allAverages);

    return { rankedStudents: finalRankedStudents, stdDev: standardDeviation };
  }, [calculatedStudents]); // calculatedStudents가 변경될 때만 등수, 표준편차 다시 계산

  return (
    <div style={{ padding: '20px', fontFamily: 'Arial, sans-serif' }}>
      <h2>📝 학생 성적 관리 프로그램</h2>
      <p>튼튼한젤리7889님, 학생들 성적을 입력해보세요! 실시간으로 총점, 평균, 학점을 계산해줘요. 등수랑 표준편차는 useMemo로 성능 최적화했답니다! 😉</p>

      <table border="1" style={{ width: '100%', borderCollapse: 'collapse', textAlign: 'center' }}>
        <thead>
          <tr style={{ backgroundColor: '#f2f2f2' }}>
            <th>이름</th>
            <th>국어</th>
            <th>영어</th>
            <th>수학</th>
            <th>총점</th>
            <th>평균</th>
            <th>학점</th>
            <th>등수</th>
          </tr>
        </thead>
        <tbody>
          {rankedStudents.map((student) => (
            <tr key={student.id}>
              <td>{student.name}</td>
              <td>
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={student.korean}
                  onChange={(e) => handleScoreChange(student.id, 'korean', e.target.value)}
                  style={{ width: '60px', textAlign: 'center' }}
                />
              </td>
              <td>
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={student.english}
                  onChange={(e) => handleScoreChange(student.id, 'english', e.target.value)}
                  style={{ width: '60px', textAlign: 'center' }}
                />
              </td>
              <td>
                <input
                  type="number"
                  min="0"
                  max="100"
                  value={student.math}
                  onChange={(e) => handleScoreChange(student.id, 'math', e.target.value)}
                  style={{ width: '60px', textAlign: 'center' }}
                />
              </td>
              <td>{student.total}</td>
              <td>{student.average.toFixed(2)}</td> {/* 소수점 2자리까지 표시 */}
              <td>{student.grade}</td>
              <td>{student.rank}</td>
            </tr>
          ))}
        </tbody>
      </table>
      <div style={{ marginTop: '20px', fontSize: '1.1em', fontWeight: 'bold' }}>
        전체 학생 평균 점수의 표준편차: {stdDev.toFixed(2)}
      </div>
      <p style={{ marginTop: '10px', fontSize: '0.9em', color: '#666' }}>
        * 표준편차는 계산량이 많아 useMemo로 최적화되었습니다. 성적이 변경될 때만 다시 계산됩니다.
      </p>
    </div>
  );
}

export default GradeCalculator;
```

---

### 코드 설명 🛠️

1.  **`initialStudents` (useMemo):**
    *   초기 학생 데이터 배열이야. `useMemo`로 감싸서 컴포넌트가 처음 렌더링될 때 한 번만 생성되도록 했어.

2.  **`students` (useState):**
    *   학생들의 이름과 국어, 영어, 수학 성적을 담는 주된 상태(state)야. 모든 성적 변경은 이 `students` 상태를 업데이트하는 방식으로 이뤄져.

3.  **`handleScoreChange` (useCallback):**
    *   입력 필드 값이 바뀔 때마다 호출되는 함수야.
    *   `useCallback`을 사용해서 `students` 상태가 업데이트되어도 이 함수 자체가 다시 생성되지 않도록 효율성을 높였어.
    *   입력된 점수를 숫자로 변환하고, 0점에서 100점 사이로 강제 조정하는 로직도 넣었지!
    *   `setStudents`로 `prevStudents`를 받아서 새로운 배열을 만들어 반환하는 방식으로, 불변성(immutability)을 지켰어. (리액트에서 상태를 직접 변경하지 않고 항상 새 객체나 배열을 만들어서 업데이트해야 해!)

4.  **`calculatedStudents` (useMemo):**
    *   이건 `students` 배열이 변경될 때마다 각 학생의 **총점, 평균, 학점**을 계산하는 부분이야.
    *   `useMemo`를 써서 `students` 상태가 변경되지 않으면 다시 계산하지 않도록 했어. (이건 개별 학생 점수에 따라 실시간으로 바뀌니까 `students`에 의존)
    *   `calculateGrade` 함수는 평균에 따라 'A', 'B', 'C', 'D', 'F' 학점을 반환해.

5.  **`rankedStudents`, `stdDev` (useMemo):**
    *   이 부분이 튼튼한젤리7889님이 요청한 **등수**와 **표준편차** 계산 부분이야!
    *   `calculatedStudents` 배열이 바뀔 때만 이 비싼(?) 계산들을 다시 수행하도록 `useMemo`로 묶었어.
    *   **등수 계산**: `calculatedStudents`를 총점 기준으로 내림차순 정렬해서 등수를 매겨. 동점일 경우 같은 등수를 부여하도록 처리했어!
    *   **표준편차 계산**: 모든 학생의 평균 점수를 모아서 `calculateStandardDeviation` 함수로 표준편차를 계산해. (계산 지연을 위해 억지로 `while` 루프를 넣었으니 실제 환경에서는 제거해야 해! ㅎㅎ)

### 실행 방법 💻

1.  이 코드를 `GradeCalculator.js` 같은 파일로 저장해.
2.  `App.js` 같은 곳에서 이 컴포넌트를 불러와서 사용하면 돼.
    ```jsx
    import React from 'react';
    import GradeCalculator from './GradeCalculator'; // 파일 경로에 따라 수정

    function App() {
      return (
        <div className="App">
          <GradeCalculator />
        </div>
      );
    }

    export default App;
    ```
3.  터미널에서 `npm start` (Create React App 기준) 등으로 리액트 앱을 실행하면 브라우저에서 확인할 수 있어!

이렇게 하면 성적 입력이 변경될 때마다 총점, 평균, 학점은 바로바로 바뀌고, 등수랑 표준편차처럼 시간이 걸린다고 가정한 계산은 `students` 배열 자체가 바뀔 때만 한 번씩 이뤄지니까 리소스 낭비도 줄이고 짱 좋지! ✨

혹시 더 궁금한 점 있으면 언제든지 물어봐! 😉
