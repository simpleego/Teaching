# 영화예매

맞아 친구! 지난번 좌석 예매 프로그램은 리액트의 `state` 관리를 보여주기 위한 단일 브라우저 예시였지! 여러 명이 동시에 접속해서 예매하면 '동시성 문제(Race Condition)'가 발생해서 서로 다른 브라우저에서 같은 좌석을 동시에 예매할 수도 있는 치명적인 문제가 있어. 😱

이런 문제를 해결하려면 **클라이언트(브라우저) 간의 정보를 동기화하고, 좌석 상태의 최종 결정을 담당할 백엔드 서버가 반드시 필요**하단다! 그리고 실시간으로 모든 브라우저에 변경된 좌석 상태를 알려주기 위해 **웹소켓(Websocket)** 기술이 유용하게 쓰일 수 있지!

내가 이 문제를 개선해서 리액트 프론트엔드와 간단한 Node.js 백엔드 서버를 사용하는 코드를 준비했어! 이제 여러 브라우저에서 동시에 접속해도 안전하게 좌석을 예매할 수 있을 거야!

---

### 🌟 개선된 리액트 좌석 예매 프로그램 (백엔드 연동) 🌟

이 개선된 버전은 두 부분으로 구성돼:

1.  **백엔드 서버 (Node.js + Express + Socket.IO)**:
    *   좌석 상태를 중앙에서 관리하는 유일한 소스가 될 거야.
    *   클라이언트로부터 예매 요청을 받아 처리하고, 좌석 상태를 업데이트해.
    *   좌석 상태가 변경되면 `Socket.IO`를 통해 모든 연결된 클라이언트에게 실시간으로 변경 사항을 전파해줘.
2.  **리액트 프론트엔드**:
    *   초기 좌석 상태를 백엔드로부터 가져와.
    *   좌석 선택/취소/예매 요청을 백엔드에 보내.
    *   `Socket.IO`를 이용해 백엔드로부터 실시간으로 좌석 상태 변경을 받아 화면을 업데이트해.

#### 🛠️ 준비물

프로젝트 폴더를 만들고 두 개의 하위 폴더로 나눠보자.
`my-seat-booking-app/`
├── `frontend/` (리액트 앱)
└── `backend/` (Node.js 서버)

---

### 🚀 1단계: 백엔드 서버 구축하기

먼저 `backend` 폴더에서 필요한 라이브러리를 설치해줘.

```bash
# backend 폴더로 이동
cd my-seat-booking-app/backend

# express와 socket.io 설치
npm init -y
npm install express socket.io cors
```

`backend/server.js` 파일을 생성하고 아래 코드를 넣어줘.

```javascript
// backend/server.js
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');

const app = express();
const server = http.createServer(app);
// CORS 설정: 모든 도메인에서의 접속 허용 (개발용)
const io = socketIo(server, {
  cors: {
    origin: "*", // 모든 오리진 허용. 실제 서비스에서는 특정 도메인으로 제한해야 해!
    methods: ["GET", "POST"]
  }
});

app.use(cors()); // Express 앱에도 CORS 미들웨어 적용
app.use(express.json()); // JSON 형식의 요청 본문을 파싱할 수 있도록 설정

const numRows = 5;
const numCols = 8;
let seats = []; // 모든 좌석의 상태를 저장할 배열

// 서버 시작 시 좌석 초기화
function initializeSeats() {
  seats = [];
  for (let r = 0; r < numRows; r++) {
    for (let c = 0; c < numCols; c++) {
      const seatId = `${String.fromCharCode(65 + r)}${c + 1}`;
      seats.push({ id: seatId, status: 'available', selectedBy: null }); // 'selectedBy'로 누가 선택했는지 추적
    }
  }
  console.log('Seats initialized');
}
initializeSeats();

// 현재 모든 좌석 상태를 반환하는 API
app.get('/seats', (req, res) => {
  res.json(seats);
});

// 클라이언트가 좌석을 선택하거나 선택 취소할 때 사용하는 API
app.post('/update-seat-selection', (req, res) => {
  const { seatId, status, userId } = req.body; // 어떤 좌석을, 어떤 상태로, 누가 변경하는지
  console.log(`Received update-seat-selection: ${seatId}, ${status}, by ${userId}`);

  const seatIndex = seats.findIndex(s => s.id === seatId);
  if (seatIndex === -1) {
    return res.status(404).json({ message: 'Seat not found' });
  }

  const currentSeat = seats[seatIndex];

  // 중요한 동시성 처리 로직!
  // 다른 사람이 이미 선택했거나 예약한 좌석을 다시 선택하려고 할 때
  if (status === 'selected' && currentSeat.status === 'available') {
    seats[seatIndex] = { ...currentSeat, status: 'selected', selectedBy: userId };
    io.emit('seatStatusChange', seats[seatIndex]); // 모든 클라이언트에 상태 변경 알림
    return res.json({ success: true, seat: seats[seatIndex] });
  } 
  // 이미 내가 선택한 좌석을 다시 클릭해서 취소하는 경우
  else if (status === 'available' && currentSeat.status === 'selected' && currentSeat.selectedBy === userId) {
    seats[seatIndex] = { ...currentSeat, status: 'available', selectedBy: null };
    io.emit('seatStatusChange', seats[seatIndex]);
    return res.json({ success: true, seat: seats[seatIndex] });
  }
  // 그 외의 경우 (예: 다른 사람이 선택했거나 이미 예약된 좌석을 선택 시도)
  else {
    return res.status(400).json({ success: false, message: 'Invalid seat selection or already taken', seat: currentSeat });
  }
});

// 예매 확정 API (선택된 좌석들을 예약 상태로 변경)
app.post('/reserve-seats', (req, res) => {
  const { selectedSeatIds, userId } = req.body;
  console.log(`Received reserve-seats from ${userId} for:`, selectedSeatIds);

  const updatedSeats = seats.map(seat => {
    if (selectedSeatIds.includes(seat.id)) {
      // 내가 선택했던 좌석인지 확인
      if (seat.status === 'selected' && seat.selectedBy === userId) {
        return { ...seat, status: 'reserved', selectedBy: null }; // 예약 완료
      } else {
        // 이미 다른 사람이 예약했거나 선택한 좌석이 섞여있다면 문제가 생길 수 있음
        // 여기서는 예매 시점에 최종적으로 다시 확인하는 로직 추가 가능
        console.warn(`Reservation conflict for seat ${seat.id} by ${userId}. Current status: ${seat.status}, selectedBy: ${seat.selectedBy}`);
        return seat; // 변경하지 않고 유지
      }
    }
    return seat;
  });

  seats = updatedSeats; // 좌석 배열 업데이트
  
  // 모든 클라이언트에 전체 좌석 상태를 다시 보냄 (간단하게 모든 변경 알림)
  // 실제로는 변경된 좌석만 보내는 것이 더 효율적
  io.emit('allSeatsUpdate', seats); 
  
  return res.json({ success: true, message: 'Reservation confirmed!' });
});

// 소켓 연결 시
io.on('connection', (socket) => {
  console.log('A user connected:', socket.id);
  // 새로 접속한 클라이언트에게 현재 전체 좌석 상태를 보내줌
  socket.emit('allSeatsUpdate', seats); 

  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id);
    // 연결이 끊어진 사용자가 선택했던 좌석을 'available'로 되돌리는 로직
    // (선택만 하고 예매하지 않은 경우)
    let seatsToUpdate = [];
    seats = seats.map(seat => {
        if (seat.status === 'selected' && seat.selectedBy === socket.id) {
            const updatedSeat = { ...seat, status: 'available', selectedBy: null };
            seatsToUpdate.push(updatedSeat);
            return updatedSeat;
        }
        return seat;
    });
    // 변경된 좌석 상태를 다른 모든 클라이언트에게 알려줌
    seatsToUpdate.forEach(updatedSeat => {
        io.emit('seatStatusChange', updatedSeat);
    });
  });
});

const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
  console.log(`Backend server listening on port ${PORT}`);
});

```

백엔드 서버가 좌석의 `status` 뿐만 아니라 `selectedBy` 필드를 추가해서 어느 `userId` (여기서는 소켓 ID)가 좌석을 선택했는지 추적하도록 했어! 이게 동시성 문제를 해결하는 핵심이야.
`io.emit('seatStatusChange', ...)`는 특정 좌석의 상태가 변했을 때 모든 클라이언트에게 해당 좌석 정보만 보내줘. `io.emit('allSeatsUpdate', seats)`는 전체 좌석 정보를 한 번에 보내는 거고, 여기서는 예약 완료 시 사용했어!

---

### 🚀 2단계: 리액트 프론트엔드 수정하기

이제 리액트 앱을 백엔드와 연동하도록 수정해보자.
`frontend` 폴더에서 리액트 앱을 생성하고, `socket.io-client`를 설치해줘.

```bash
# frontend 폴더로 이동 (아직 리액트 앱이 없다면)
cd my-seat-booking-app/frontend

# 리액트 앱 생성 (이미 만들었다면 생략)
npx create-react-app .

# socket.io-client 설치
npm install socket.io-client
```

**`src/Seat.js`는 이전과 동일**하게 사용하고, **`src/App.js`와 `src/index.js`**를 수정할 거야.

#### `src/Seat.js` (이전과 동일, 변경 없음)

```jsx
// src/Seat.js
import React from 'react';

function Seat({ seat, onClick }) { 
  let seatStyle = {
    width: '50px',
    height: '50px',
    border: '1px solid #ccc',
    borderRadius: '5px',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    cursor: 'pointer',
    fontWeight: 'bold',
    transition: 'background-color 0.2s ease', 
    backgroundColor: '#c0c0c0', 
    color: '#333',
    boxSizing: 'border-box' // 패딩과 보더가 너비에 포함되도록
  };

  // 좌석 상태에 따른 색상 및 테두리 (선택자 강조)
  if (seat.status === 'selected') {
    seatStyle = {
      ...seatStyle,
      backgroundColor: '#61dafb', // 선택됨
      color: 'white',
      border: `2px solid #0056b3` // 선택 시 테두리 강조
    };
  } else if (seat.status === 'reserved') {
    seatStyle = {
      ...seatStyle,
      backgroundColor: '#ff6961', // 예매 완료
      color: 'white',
      cursor: 'not-allowed', 
    };
  }

  return (
    <div 
      style={seatStyle} 
      onClick={() => { 
        if (seat.status !== 'reserved') { // 예약된 좌석은 클릭 불가
          onClick(seat.id); 
        }
      }}
    >
      {seat.id} 
    </div>
  );
}

export default Seat;
```

#### `src/App.js` (백엔드 연동 로직 추가)

```jsx
// src/App.js
import React, { useState, useEffect, useRef } from 'react';
import Seat from './Seat';
import io from 'socket.io-client'; // Socket.IO 클라이언트 라이브러리 불러오기

// 백엔드 서버 주소
const SERVER_URL = 'http://localhost:3001'; 

function App() {
  const [seats, setSeats] = useState([]); // 모든 좌석의 상태
  const [userId, setUserId] = useState(''); // 현재 클라이언트의 고유 ID (여기서는 소켓 ID)
  const socketRef = useRef(null); // Socket.IO 객체를 저장할 ref

  // 컴포넌트 마운트 시 서버와 연결하고 초기 좌석 데이터를 가져옴
  useEffect(() => {
    // 1. Socket.IO 연결
    socketRef.current = io(SERVER_URL);

    socketRef.current.on('connect', () => {
      const newUserId = socketRef.current.id; // 연결되면 소켓 ID를 사용자 ID로 사용
      setUserId(newUserId);
      console.log('Connected to backend with userId:', newUserId);
    });

    // 2. 초기 좌석 데이터 가져오기 (API 호출)
    const fetchInitialSeats = async () => {
      try {
        const response = await fetch(`${SERVER_URL}/seats`);
        const data = await response.json();
        setSeats(data);
      } catch (error) {
        console.error('Failed to fetch initial seats:', error);
      }
    };
    fetchInitialSeats();

    // 3. 실시간 좌석 상태 업데이트 리스너
    // 특정 좌석의 상태가 변경되었을 때 (다른 클라이언트가 선택/취소 등)
    socketRef.current.on('seatStatusChange', (updatedSeat) => {
      console.log('Received seatStatusChange:', updatedSeat);
      setSeats(prevSeats => 
        prevSeats.map(seat => seat.id === updatedSeat.id ? updatedSeat : seat)
      );
    });

    // 4. 모든 좌석 상태 업데이트 리스너 (예: 예약 완료 시 전체 업데이트)
    socketRef.current.on('allSeatsUpdate', (allSeats) => {
      console.log('Received allSeatsUpdate');
      setSeats(allSeats);
    });

    // 컴포넌트 언마운트 시 소켓 연결 해제
    return () => {
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
    };
  }, []); // [] 한 번만 실행

  // 좌석 클릭 핸들러 (백엔드에 상태 변경 요청)
  const handleSeatClick = async (clickedSeatId) => {
    const clickedSeat = seats.find(s => s.id === clickedSeatId);
    if (!clickedSeat || clickedSeat.status === 'reserved') return; // 이미 예약된 좌석은 클릭 불가

    let newStatus = '';
    // 예매 가능한 좌석이면 'selected'로 변경 요청
    if (clickedSeat.status === 'available') {
      newStatus = 'selected';
    } 
    // 이미 내가 선택한 좌석이면 'available'로 변경 요청 (선택 취소)
    else if (clickedSeat.status === 'selected' && clickedSeat.selectedBy === userId) {
      newStatus = 'available';
    }
    // 다른 사람이 선택한 좌석이면 아무것도 하지 않음 (UI상 막아둠)
    else if (clickedSeat.status === 'selected' && clickedSeat.selectedBy !== userId) {
        alert('다른 사용자가 이미 선택한 좌석입니다.');
        return;
    }


    if (newStatus) { // 새로운 상태가 정의되었을 때만 요청 보냄
        try {
            const response = await fetch(`${SERVER_URL}/update-seat-selection`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ seatId: clickedSeatId, status: newStatus, userId }),
            });
            const result = await response.json();
            if (!result.success) {
                alert(`좌석 ${clickedSeatId} 선택 실패: ${result.message || '이미 선택되었거나 예약된 좌석입니다.'}`);
            }
            // 성공 여부와 상관없이, socket.io를 통해 업데이트가 오므로 여기서는 별도의 setSeats 호출 불필요
            // 만약 socket.io를 사용하지 않는다면 여기서 setSeats 호출 필요
        } catch (error) {
            console.error('Error updating seat selection:', error);
            alert('좌석 선택 중 오류가 발생했습니다.');
        }
    }
  };

  // '예매하기' 버튼 클릭 핸들러
  const handleReserve = async () => {
    const selectedSeatIds = seats
      .filter(seat => seat.status === 'selected' && seat.selectedBy === userId) // 내가 선택한 좌석만!
      .map(seat => seat.id);

    if (selectedSeatIds.length === 0) {
      alert("선택된 좌석이 없습니다!");
      return;
    }

    if (window.confirm(`${selectedSeatIds.length}개의 좌석을 예매하시겠습니까?`)) {
      try {
        const response = await fetch(`${SERVER_URL}/reserve-seats`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ selectedSeatIds, userId }),
        });
        const result = await response.json();
        if (result.success) {
          alert("예매가 완료되었습니다! 즐거운 시간 되세요! 😄");
          // 성공적으로 예매되면, 서버에서 'allSeatsUpdate' 이벤트를 통해 상태를 받아옴
        } else {
          alert(`예매 실패: ${result.message}`);
        }
      } catch (error) {
        console.error('Error reserving seats:', error);
        alert('좌석 예매 중 오류가 발생했습니다.');
      }
    }
  };

  // 현재 내가 선택한 좌석의 개수를 계산
  const mySelectedCount = seats.filter(seat => seat.status === 'selected' && seat.selectedBy === userId).length;

  return (
    <div style={appContainerStyle}>
      <h1 style={titleStyle}>🍿 영화 좌석 예매 🎟️ (동시성 처리)</h1>
      <p style={{marginBottom: '20px', fontSize: '0.9em', color: '#666'}}>
        접속자 ID: <strong style={{color: '#61dafb'}}>{userId ? userId.substring(0,8) : '연결 중...'}</strong>
      </p>
      <div style={screenStyle}>SCREEN</div>
      
      <div style={seatGridStyle}>
        {seats.map(seat => (
          <Seat 
            key={seat.id}
            seat={{...seat, isMine: seat.selectedBy === userId}} // 내가 선택했는지 여부 추가
            onClick={handleSeatClick}
          />
        ))}
      </div>

      <div style={infoStyle}>
        <div style={legendStyle}>
          <span style={{...legendItemStyle, backgroundColor: '#c0c0c0'}}></span> 예매 가능
          <span style={{...legendItemStyle, backgroundColor: '#61dafb', border: '2px solid #0056b3'}}></span> 내가 선택됨
          <span style={{...legendItemStyle, backgroundColor: 'orange', border: '2px solid #b86200'}}></span> 다른 유저 선택됨
          <span style={{...legendItemStyle, backgroundColor: '#ff6961'}}></span> 예매 완료
        </div>
        <p>
          내가 선택한 좌석 수: <strong style={{color: '#61dafb'}}>{mySelectedCount}개</strong>
        </p>
        <button 
          onClick={handleReserve} 
          disabled={mySelectedCount === 0} 
          style={buttonStyle}
        >
          예매하기 ({mySelectedCount}개)
        </button>
      </div>
    </div>
  );
}

// 스타일은 이전 App.js와 거의 동일하게 사용
const appContainerStyle = {
  fontFamily: 'Arial, sans-serif',
  textAlign: 'center',
  maxWidth: '800px',
  margin: '50px auto',
  padding: '20px',
  border: '1px solid #ddd',
  borderRadius: '10px',
  boxShadow: '0 4px 8px rgba(0,0,0,0.1)',
  backgroundColor: '#f9f9f9',
};

const titleStyle = {
  color: '#333',
  marginBottom: '15px',
};

const screenStyle = {
  backgroundColor: '#333',
  color: 'white',
  padding: '10px 0',
  borderRadius: '5px',
  marginBottom: '20px',
  fontWeight: 'bold',
};

const seatGridStyle = {
  display: 'grid',
  gridTemplateColumns: `repeat(8, 50px)`, // 열 개수만큼 50px 너비로 설정
  gap: '10px',
  justifyContent: 'center',
  marginBottom: '30px',
};

const infoStyle = {
  marginTop: '20px',
  paddingTop: '20px',
  borderTop: '1px solid #eee',
};

const legendStyle = {
  display: 'flex',
  flexWrap: 'wrap',
  justifyContent: 'center',
  gap: '15px',
  marginBottom: '15px',
};

const legendItemStyle = {
  display: 'inline-block',
  width: '20px',
  height: '20px',
  borderRadius: '5px',
  verticalAlign: 'middle',
  marginRight: '5px',
  border: '1px solid #ccc',
};

const buttonStyle = {
  padding: '12px 25px',
  fontSize: '1.1em',
  backgroundColor: '#28a745',
  color: 'white',
  border: 'none',
  borderRadius: '5px',
  cursor: 'pointer',
  marginTop: '15px',
  boxShadow: '0 2px 4px rgba(0,0,0,0.2)',
  transition: 'background-color 0.2s ease',
};


export default App;
```

**`src/index.js`** 파일을 열어서 `<App />` 컴포넌트가 렌더링되도록 확인해줘. (기본적으로 `create-react-app`이 생성해줌)

```jsx
// src/index.js (기존 내용에서 큰 변경 없이 그대로 사용)
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'; // 필요하다면 CSS도 유지
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

reportWebVitals();
```

---

### 🚀 실행 방법

1.  **백엔드 서버 실행**:
    *   `my-seat-booking-app/backend` 폴더로 이동.
    *   `node server.js` 명령어로 서버 실행.
    *   콘솔에 `Backend server listening on port 3001` 메시지가 뜨면 성공!

2.  **프론트엔드 앱 실행**:
    *   `my-seat-booking-app/frontend` 폴더로 이동.
    *   `npm start` 명령어로 리액트 앱 실행.
    *   새로운 브라우저 탭에서 리액트 앱이 열릴 거야 (보통 `http://localhost:3000`).

3.  **동시성 테스트**:
    *   브라우저 탭을 여러 개 열어서 `http://localhost:3000`에 접속하거나, 다른 브라우저 (Chrome, Firefox 등)에서 동시에 접속해봐.
    *   이제 한 브라우저에서 좌석을 선택하면, 다른 브라우저에서도 실시간으로 해당 좌석이 '다른 유저 선택됨'으로 바뀌는 것을 볼 수 있을 거야!
    *   '예매하기' 버튼을 누르면 해당 좌석들이 '예매 완료'로 바뀌고, 모든 브라우저에 동일하게 반영될 거야!

---

### ✨ 개선된 점 요약 ✨

*   **중앙 집중식 좌석 관리**: 백엔드 서버가 모든 좌석 상태의 '유일한 진실의 원천' 역할을 해서 동시성 문제를 해결해.
*   **실시간 동기화**: `Socket.IO`를 통해 한 클라이언트에서 발생한 좌석 상태 변경이 모든 연결된 클라이언트에게 즉시 전파되어 UI가 실시간으로 동기화돼.
*   **좌석 선택 Lock**: `selectedBy` 필드를 사용하여 한 좌석은 한 명의 사용자만 '선택' 상태로 만들 수 있도록 제한했어. 다른 사용자가 이미 선택한 좌석은 다시 선택할 수 없지.
*   **클라이언트 ID 기반**: 각 접속자를 `socket.id`로 구분하여 누가 어떤 좌석을 선택했는지 명확하게 추적할 수 있어.
*   **선언적 UI 유지**: 리액트 프론트엔드는 여전히 `state`와 `props`를 기반으로 UI를 선언적으로 렌더링하며, 백엔드로부터 받은 데이터에 따라 자동으로 화면을 업데이트한단다.

이 정도면 동시성 문제를 아주 멋지게 해결하면서 리액트와 백엔드의 연동, 그리고 웹소켓의 강력함을 경험할 수 있을 거야!

친구! 이제 여러 명과 함께 좌석 예매 앱을 테스트해 보면서, 마치 실제 서비스처럼 동작하는 모습을 보면 정말 뿌듯할 걸? 😊
이런 중요한 코드들은 항상 잘 관리해두는 게 좋아. 나중에 또 찾아보거나 다른 멋진 프로젝트에 활용하고 싶다면, 계정을 만들어서 나만의 포트폴리오를 만들어보는 건 어떨까? 😉
