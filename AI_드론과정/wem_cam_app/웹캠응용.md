# ì›¹ìº ì‘ìš©
>  ì´ì œ **1ë‹¨ê³„(ì–¼êµ´ ê²€ì¶œ) + 2ë‹¨ê³„(ë¹¨ê°„ìƒ‰ ì¶”ì ) + 3ë‹¨ê³„(ê²€ì¶œ ì˜ì—­ ë¡œê·¸ ì €ì¥)**

ì´ ì½”ë“œëŠ” ë‹¤ìŒì„ ë™ì‹œì— ìˆ˜í–‰í•´:

- ì›¹ìº ì—ì„œ ì‹¤ì‹œê°„ ì˜ìƒ ì…ë ¥  
- ì–¼êµ´ ê²€ì¶œ (Haar Cascade)  
- ë¹¨ê°„ìƒ‰ ë¬¼ì²´ ì¶”ì  (HSV ê¸°ë°˜)  
- ì›€ì§ì„ ê²€ì¶œ (ë°°ê²½ ì°¨ë¶„)  
- ê²€ì¶œëœ ëª¨ë“  ì˜ì—­ì˜ ì¢Œí‘œ/í¬ê¸°ë¥¼ ë¡œê·¸ íŒŒì¼ì— ì €ì¥  
- x í‚¤ë¡œ ì¢…ë£Œ  

---

# ğŸŸ¦ **í†µí•© í”„ë¡œê·¸ë¨ (ì–¼êµ´ + ë¹¨ê°„ìƒ‰ + ì›€ì§ì„ + ë¡œê·¸ ì €ì¥)**

```python
import cv2
import numpy as np
import datetime

def main():
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        print("ì›¹ìº ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return

    # 1) ì–¼êµ´ ê²€ì¶œìš© Haar Cascade
    face_cascade = cv2.CascadeClassifier(
        cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
    )

    # 2) ì›€ì§ì„ ê²€ì¶œìš© ë°°ê²½ ì°¨ë¶„ê¸°
    back_sub = cv2.createBackgroundSubtractorMOG2(history=500, varThreshold=50, detectShadows=True)

    # 3) ë¡œê·¸ íŒŒì¼ ìƒì„±
    log_file = open("detection_log.txt", "w", encoding="utf-8")
    log_file.write("time,type,x,y,w,h,area\n")

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        frame = cv2.resize(frame, (640, 480))
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

        # ============================
        # 1ï¸âƒ£ ì–¼êµ´ ê²€ì¶œ
        # ============================
        faces = face_cascade.detectMultiScale(
            gray, scaleFactor=1.3, minNeighbors=5, minSize=(50, 50)
        )

        for (x, y, w, h) in faces:
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)

            now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_file.write(f"{now},face,{x},{y},{w},{h},{w*h}\n")

        # ============================
        # 2ï¸âƒ£ ë¹¨ê°„ìƒ‰ ë¬¼ì²´ ì¶”ì 
        # ============================
        lower_red1 = np.array([0, 120, 70])
        upper_red1 = np.array([10, 255, 255])
        lower_red2 = np.array([170, 120, 70])
        upper_red2 = np.array([180, 255, 255])

        mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
        mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
        red_mask = mask1 | mask2

        red_mask = cv2.morphologyEx(red_mask, cv2.MORPH_OPEN, np.ones((5, 5), np.uint8))
        red_mask = cv2.morphologyEx(red_mask, cv2.MORPH_DILATE, np.ones((5, 5), np.uint8))

        contours, _ = cv2.findContours(red_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area < 500:
                continue

            x, y, w, h = cv2.boundingRect(cnt)
            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 0, 255), 2)

            now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_file.write(f"{now},red,{x},{y},{w},{h},{area}\n")

        # ============================
        # 3ï¸âƒ£ ì›€ì§ì„ ê²€ì¶œ
        # ============================
        fg_mask = back_sub.apply(frame)
        _, thresh = cv2.threshold(fg_mask, 200, 255, cv2.THRESH_BINARY)
        thresh = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))
        thresh = cv2.dilate(thresh, np.ones((3, 3), np.uint8), iterations=2)

        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area < 800:
                continue

            x, y, w, h = cv2.boundingRect(cnt)
            cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 255, 0), 2)

            now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_file.write(f"{now},motion,{x},{y},{w},{h},{area}\n")

        # ============================
        # í™”ë©´ ì¶œë ¥
        # ============================
        cv2.imshow("Integrated Detection (press x to exit)", frame)

        key = cv2.waitKey(1) & 0xFF
        if key == ord('x'):
            break

    log_file.close()
    cap.release()
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
```

---

# ğŸ“Œ **ì´ í†µí•© í”„ë¡œê·¸ë¨ì´ í•˜ëŠ” ì¼**

| ê¸°ëŠ¥ | ì„¤ëª… |
|------|------|
| ì–¼êµ´ ê²€ì¶œ | Haar Cascadeë¡œ ì–¼êµ´ ìœ„ì¹˜ í‘œì‹œ |
| ë¹¨ê°„ìƒ‰ ì¶”ì  | HSV ìƒ‰ê³µê°„ì—ì„œ ë¹¨ê°„ìƒ‰ë§Œ ì¶”ì  |
| ì›€ì§ì„ ê²€ì¶œ | ë°°ê²½ ì°¨ë¶„ìœ¼ë¡œ ì›€ì§ì„ ì˜ì—­ í‘œì‹œ |
| ë¡œê·¸ ì €ì¥ | ì–¼êµ´/ë¹¨ê°„ìƒ‰/ì›€ì§ì„ ê²€ì¶œ ì‹œ ì¢Œí‘œÂ·í¬ê¸° ê¸°ë¡ |
| ì¢…ë£Œ | x í‚¤ë¡œ ì¢…ë£Œ |

---

# ğŸ“„ **ë¡œê·¸ íŒŒì¼ ì˜ˆì‹œ (detection_log.txt)**

```
time,type,x,y,w,h,area
2026-02-03 21:30:12,face,120,80,60,90,5400
2026-02-03 21:30:13,red,200,150,40,50,2100
2026-02-03 21:30:14,motion,50,200,80,120,9600
```

---

í•„ìš”í•˜ë©´ ë‹¤ìŒë„ ë§Œë“¤ì–´ì¤„ ìˆ˜ ìˆì–´:

- ê²€ì¶œëœ ì–¼êµ´/ë¬¼ì²´ë¥¼ ì´ë¯¸ì§€ë¡œ ìë™ ì €ì¥  
- FastAPI ì„œë²„ë¡œ ê²€ì¶œ ë¡œê·¸ ì „ì†¡  
- YOLO ê¸°ë°˜ ê³ ì„±ëŠ¥ ê°ì²´ ê²€ì¶œ ë²„ì „  
- GUI(ë²„íŠ¼/ìŠ¬ë¼ì´ë”) ì¶”ê°€ ë²„ì „  

ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ í™•ì¥í•˜ê³  ì‹¶ì–´?
