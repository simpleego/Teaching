# 웹캠최적화 방법

## **웹캠 초기화 시간을 줄이는 방법**

### **1. 웹캠 설정 최적화**

```python
class OptimizedWebcamDrone(WebcamVirtualDrone):
    def __init__(self, drone_id="DRONE_001", camera_index=0, optimize_speed=True):
        super().__init__(drone_id, camera_index)
        self.optimize_speed = optimize_speed
        self.camera_ready = False
        
    def initialize_camera_fast(self):
        """빠른 웹캠 초기화"""
        try:
            # 작은 해상도로 먼저 열기 (빠른 초기화)
            self.cap = cv2.VideoCapture(self.camera_index, cv2.CAP_DSHOW)  # Windows에서는 DSHOW 사용
            
            if not self.cap.isOpened():
                print(f"[ERROR] 웹캠을 열 수 없습니다.")
                return False
            
            # 최소한의 설정만 초기화 (빠른 시작)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)  # 작은 해상도로 시작
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)
            
            # 버퍼 크기 줄이기
            self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
            
            # 몇 프레임 읽어서 초기화 (웜업)
            for _ in range(5):
                ret, frame = self.cap.read()
                if not ret:
                    break
            
            print(f"[SYSTEM] 웹캠 빠른 초기화 완료")
            self.camera_ready = True
            
            # 백그라운드에서 고해상도로 변경
            threading.Thread(target=self._enhance_resolution, daemon=True).start()
            
            return True
            
        except Exception as e:
            print(f"[ERROR] 웹캠 초기화 실패: {e}")
            return False
    
    def _enhance_resolution(self):
        """백그라운드에서 해상도 향상"""
        time.sleep(1)  # 사용자 상호작용 기다림
        if self.cap and self.cap.isOpened():
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.frame_width)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.frame_height)
            print(f"[SYSTEM] 해상도 향상 완료: {self.frame_width}x{self.frame_height}")
    
    def start_camera_fast(self):
        """빠른 카메라 시작"""
        if not self.camera_ready:
            if not self.initialize_camera_fast():
                return False
        
        self.camera_on = True
        return True
```

### **2. 비동기 초기화 (Async) - 가장 효과적**

```python
import asyncio
import threading

class AsyncWebcamDrone:
    def __init__(self, drone_id="DRONE_001", camera_index=0):
        self.id = drone_id
        self.camera_index = camera_index
        self.cap = None
        self.camera_on = False
        self.camera_initializing = False
        self.camera_ready_event = threading.Event()
        
        # 백그라운드에서 웹캠 초기화 시작
        self._init_camera_async()
    
    def _init_camera_async(self):
        """비동기로 웹캠 초기화"""
        def init_in_background():
            self.camera_initializing = True
            try:
                self.cap = cv2.VideoCapture(self.camera_index)
                if self.cap.isOpened():
                    # 최소 설정만 초기화
                    self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)
                    self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)
                    
                    # 웜업: 몇 프레임 미리 읽기
                    for _ in range(10):
                        self.cap.read()
                    
                    self.camera_ready_event.set()
                    print(f"[ASYNC] 웹캠 백그라운드 초기화 완료")
                else:
                    print(f"[ASYNC] 웹캠 초기화 실패")
            except Exception as e:
                print(f"[ASYNC] 초기화 오류: {e}")
            finally:
                self.camera_initializing = False
        
        # 별도 스레드에서 초기화
        init_thread = threading.Thread(target=init_in_background, daemon=True)
        init_thread.start()
    
    def start_camera_instant(self):
        """즉시 카메라 시작 (이미 초기화됨)"""
        if self.camera_ready_event.wait(timeout=0.1):  # 이미 초기화되었는지 확인
            self.camera_on = True
            return True
        
        # 아직 초기화 중이면 대기
        if self.camera_initializing:
            print(f"[INFO] 웹캠 초기화 중... 잠시만 기다려주세요.")
            if self.camera_ready_event.wait(timeout=3.0):  # 최대 3초 대기
                self.camera_on = True
                return True
        
        return False
    
    def get_frame_fast(self):
        """빠른 프레임 캡처"""
        if not self.camera_on or not self.cap:
            return None
        
        ret, frame = self.cap.read()
        if ret:
            # 필요 시 해상도 업스케일
            if frame.shape[1] < 640:
                frame = cv2.resize(frame, (640, 480))
            return frame
        
        return None
```

### **3. 프리로딩 및 버퍼링 시스템**

```python
class BufferedWebcamDrone:
    def __init__(self, drone_id="DRONE_001", camera_index=0, buffer_size=3):
        self.id = drone_id
        self.camera_index = camera_index
        self.buffer_size = buffer_size
        self.frame_buffer = []
        self.buffer_lock = threading.Lock()
        self.streaming = False
        self.cap = None
        
        # 프레임 버퍼링 스레드 시작
        self.buffer_thread = threading.Thread(target=self._buffer_frames, daemon=True)
        
    def initialize_with_preload(self):
        """프리로딩을 통한 빠른 초기화"""
        try:
            # 웹캠 열기
            self.cap = cv2.VideoCapture(self.camera_index)
            
            if not self.cap.isOpened():
                return False
            
            # 낮은 해상도로 시작
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 320)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 240)
            self.cap.set(cv2.CAP_PROP_FPS, 30)
            self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)  # 버퍼 크기 최소화
            
            # 프리로드: 여러 프레임 미리 읽기
            preload_frames = []
            for i in range(15):  # 15프레임 프리로드
                ret, frame = self.cap.read()
                if ret:
                    preload_frames.append(frame)
                    if i % 5 == 0:
                        print(f"  프리로딩: {i+1}/15")
                else:
                    break
            
            if preload_frames:
                with self.buffer_lock:
                    self.frame_buffer = preload_frames
                
                # 버퍼링 스레드 시작
                self.streaming = True
                self.buffer_thread.start()
                
                print(f"[SYSTEM] 프리로딩 완료: {len(preload_frames)} 프레임")
                return True
            
        except Exception as e:
            print(f"[ERROR] 프리로딩 실패: {e}")
        
        return False
    
    def _buffer_frames(self):
        """백그라운드에서 프레임 버퍼링"""
        while self.streaming and self.cap and self.cap.isOpened():
            ret, frame = self.cap.read()
            if ret:
                with self.buffer_lock:
                    if len(self.frame_buffer) >= self.buffer_size:
                        self.frame_buffer.pop(0)  # 오래된 프레임 제거
                    self.frame_buffer.append(frame)
            time.sleep(0.01)  # CPU 사용량 제한
    
    def get_buffered_frame(self):
        """버퍼에서 즉시 프레임 가져오기"""
        with self.buffer_lock:
            if self.frame_buffer:
                return self.frame_buffer[-1]  # 가장 최신 프레임
        return None
    
    def start_streaming_instant(self):
        """즉시 스트리밍 시작"""
        if self.initialize_with_preload():
            print(f"[SYSTEM] 즉시 스트리밍 시작 가능")
            return True
        return False
```

### **4. 간단한 테스트 프로그램 (빠른 시작)**

```python
def test_fast_webcam():
    """빠른 웹캠 테스트"""
    print("빠른 웹캠 테스트 시작...")
    
    # 방법 1: 최적화된 드론 사용
    drone = OptimizedWebcamDrone("FAST_DRONE", camera_index=0, optimize_speed=True)
    
    print("\n1. 빠른 초기화 테스트")
    start_time = time.time()
    
    if drone.start_camera_fast():
        elapsed = time.time() - start_time
        print(f"✓ 카메라 준비 시간: {elapsed:.2f}초")
        
        # 즉시 프레임 캡처
        print("\n2. 즉시 프레임 캡처 테스트")
        drone.start_camera()
        
        for i in range(5):
            frame_start = time.time()
            image_data = drone.capture_image(save_to_file=False, show_preview=True)
            frame_time = time.time() - frame_start
            
            if image_data:
                print(f"  프레임 {i+1}: {frame_time:.3f}초")
            
            cv2.waitKey(100)  # 0.1초 대기
        
        cv2.destroyAllWindows()
    else:
        print("✗ 카메라 초기화 실패")
    
    drone.stop_camera()

def test_async_webcam():
    """비동기 웹캠 테스트"""
    print("\n비동기 웹캠 테스트 시작...")
    
    # 프로그램 시작 시 미리 초기화
    print("프로그램 시작 시 웹캠을 백그라운드에서 초기화합니다...")
    drone = AsyncWebcamDrone("ASYNC_DRONE", camera_index=0)
    
    # 다른 작업 수행 (예: UI 로딩, 설정 읽기 등)
    time.sleep(2)
    
    print("\n카메라 사용 준비 완료!")
    print("카메라 버튼을 누르면 즉시 화면이 표시됩니다.")
    
    # 사용자가 카메라 버튼 누를 때
    start_time = time.time()
    if drone.start_camera_instant():
        elapsed = time.time() - start_time
        print(f"✓ 즉시 카메라 시작: {elapsed:.2f}초")
        
        # 프레임 표시
        for i in range(10):
            frame = drone.get_frame_fast()
            if frame is not None:
                cv2.imshow("Async Webcam", frame)
                cv2.waitKey(100)
        
        cv2.destroyAllWindows()
```

### **5. 웹캠 지연 시간을 줄이는 팁**

```python
# config.py - 최적화 설정
WEB_CAM_OPTIMIZATION = {
    'USE_DSHOW': True,           # Windows: DirectShow 사용 (더 빠름)
    'LOW_RES_INIT': True,        # 낮은 해상도로 초기화
    'PRELOAD_FRAMES': 10,        # 프리로드 프레임 수
    'BUFFER_SIZE': 2,            # 버퍼 크기
    'WARMUP_FRAMES': 5,          # 웜업용 프레임 수
    'TARGET_FPS': 30,            # 목표 FPS
    'USE_MJPEG': True,           # MJPEG 코덱 사용 (있는 경우)
}

def get_optimal_camera_settings(camera_index=0):
    """최적의 카메라 설정 찾기"""
    cap = cv2.VideoCapture(camera_index)
    
    # 사용 가능한 해상도 테스트
    test_resolutions = [
        (320, 240),    # 가장 빠름
        (640, 480),    # 균형
        (1280, 720),   # HD
        (1920, 1080),  # Full HD
    ]
    
    optimal_res = (640, 480)  # 기본값
    
    for width, height in test_resolutions:
        cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
        cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
        
        actual_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
        actual_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
        
        if actual_width == width and actual_height == height:
            print(f"지원 해상도: {width}x{height}")
            # 필요한 성능에 따라 선택
            if width <= 640:  # 빠른 응답이 필요할 때
                optimal_res = (width, height)
    
    cap.release()
    return optimal_res
```

## **실행 속도 비교 테스트**

```python
def speed_comparison():
    """다양한 방법의 속도 비교"""
    methods = [
        ("기본 방법", test_basic_webcam),
        ("최적화 방법", test_fast_webcam),
        ("비동기 방법", test_async_webcam),
    ]
    
    print("="*50)
    print("웹캠 초기화 속도 비교")
    print("="*50)
    
    for method_name, test_func in methods:
        print(f"\n▶ {method_name} 테스트 중...")
        test_start = time.time()
        test_func()
        total_time = time.time() - test_start
        print(f"총 소요 시간: {total_time:.2f}초")
    
    print("\n" + "="*50)
    print("테스트 완료!")
```

## **결론 및 권장사항**

1. **첫 화면 표시 지연 원인:**
   - 웹캠 하드웨어 초기화 시간
   - 드라이버 로딩 시간
   - 자동 포커스/화이트 밸런스 조정
   - 버퍼 채우기 시간

2. **빠른 시작을 위한 최적의 방법:**
   ```python
   # 권장 조합
   class FastWebcamDrone:
       def __init__(self):
           # 1. 백그라운드에서 비동기 초기화
           # 2. 낮은 해상도로 시작
           # 3. 프리로딩 사용
           # 4. 필요 시 해상도 점진적 향상
           pass
   ```

3. **실제 적용 예시:**
   ```python
   # 프로그램 시작 시
   drone = AsyncWebcamDrone("MAIN_DRONE", 0)
   
   # UI가 준비되는 동안 백그라운드에서 웹캠 초기화
   
   # 사용자가 '카메라 시작' 버튼 클릭 시
   if drone.start_camera_instant():  # 즉시 시작
       frame = drone.get_frame_fast()
       cv2.imshow("Webcam", frame)
   ```

이러한 방법들을 사용하면 웹캠 영상 표시 지연을 0.1-0.5초 수준으로 크게 줄일 수 있습니다. 가장 중요한 것은 **백그라운드 초기화**와 **프리로딩**입니다.
