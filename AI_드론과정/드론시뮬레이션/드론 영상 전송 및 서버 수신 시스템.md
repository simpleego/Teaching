# 드론 영상 전송 및 서버 수신 시스템

## **아키텍처 개요**
- **드론(클라이언트)**: OpenCV로 가상 영상 생성/실제 카메라 사용 가능
- **통신 방식**: 
  - 근거리: Wi-Fi (UDP 소켓 통신 - 낮은 지연 시간)
  - 원거리: MAVLink 프로토콜 (실제 드론 통신 표준)
- **서버**: 영상 수신, 표시, 저장

---

## **1. Wi-Fi UDP 기반 영상 전송 시스템 (간단한 구현)**

### **1.1 공통 설정 파일**

```python
# config.py
import socket

# 네트워크 설정
DRONE_IP = "127.0.0.1"  # 드론 IP (로컬 테스트용)
SERVER_IP = "127.0.0.1"  # 서버 IP
VIDEO_PORT = 5000        # 영상 전송 포트
TELEMETRY_PORT = 5001    # 텔레메트리 포트
BUFFER_SIZE = 65536      # UDP 패킷 크기

# 영상 설정
FRAME_WIDTH = 640
FRAME_HEIGHT = 480
FPS = 30
```

### **1.2 드론 측 - 영상 전송 프로그램**

```python
# drone_video_sender.py
import cv2
import socket
import pickle
import struct
import time
import threading
import numpy as np
from config import *

class DroneVideoSender:
    def __init__(self, drone_id="DRONE_001", use_virtual_camera=True):
        self.drone_id = drone_id
        self.use_virtual_camera = use_virtual_camera
        self.is_streaming = False
        self.frame_count = 0
        
        # 소켓 설정
        self.video_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.video_socket.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, BUFFER_SIZE)
        
        # 텔레메트리 소켓
        self.telemetry_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        
        # 카메라 초기화
        self.cap = None
        if not use_virtual_camera:
            self.init_real_camera()
        else:
            print(f"[DRONE {drone_id}] 가상 카메라 모드 활성화")
        
        # 드론 상태
        self.position = {"x": 0.0, "y": 0.0, "z": 0.0}
        self.battery = 100.0
        self.is_flying = False
        
    def init_real_camera(self):
        """실제 카메라 초기화"""
        try:
            self.cap = cv2.VideoCapture(0)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, FRAME_WIDTH)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, FRAME_HEIGHT)
            self.cap.set(cv2.CAP_PROP_FPS, FPS)
            print("[DRONE] 실제 카메라 초기화 완료")
        except Exception as e:
            print(f"[ERROR] 카메라 초기화 실패: {e}")
            self.use_virtual_camera = True
    
    def generate_virtual_frame(self):
        """가상 영상 프레임 생성"""
        # 검은 배경 생성
        frame = np.zeros((FRAME_HEIGHT, FRAME_WIDTH, 3), dtype=np.uint8)
        
        # 현재 시간 표시
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        
        # 드론 정보 표시
        cv2.putText(frame, f"Drone: {self.drone_id}", (20, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.putText(frame, f"Time: {timestamp}", (20, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
        cv2.putText(frame, f"Battery: {self.battery:.1f}%", (20, 90), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 200, 255), 2)
        cv2.putText(frame, f"Position: ({self.position['x']:.1f}, {self.position['y']:.1f}, {self.position['z']:.1f})", 
                   (20, 120), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 200, 0), 2)
        cv2.putText(frame, f"Frame: {self.frame_count}", (20, 150), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (200, 200, 200), 2)
        
        # 비행 상태 표시
        status = "FLYING" if self.is_flying else "GROUNDED"
        status_color = (0, 0, 255) if self.is_flying else (100, 100, 100)
        cv2.putText(frame, f"Status: {status}", (FRAME_WIDTH-200, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, status_color, 2)
        
        # 시뮬레이션을 위한 움직이는 요소 추가
        center_x = FRAME_WIDTH // 2
        center_y = FRAME_HEIGHT // 2
        
        # 회전하는 다각형 (시뮬레이션용)
        radius = 100
        angle = (self.frame_count % 360) * np.pi / 180
        points = []
        for i in range(5):
            theta = angle + i * 2 * np.pi / 5
            x = center_x + int(radius * np.cos(theta))
            y = center_y + int(radius * np.sin(theta))
            points.append((x, y))
        
        # 다각형 그리기
        for i in range(5):
            cv2.line(frame, points[i], points[(i+1)%5], (255, 0, 0), 2)
        
        # 중앙 마커
        cv2.circle(frame, (center_x, center_y), 10, (0, 0, 255), -1)
        
        self.frame_count += 1
        return frame
    
    def capture_frame(self):
        """프레임 캡처 (실제 또는 가상)"""
        if self.use_virtual_camera:
            return self.generate_virtual_frame()
        else:
            if self.cap and self.cap.isOpened():
                ret, frame = self.cap.read()
                if ret:
                    # 실제 영상에 드론 정보 오버레이
                    self.overlay_drone_info(frame)
                    return frame
            return self.generate_virtual_frame()  # 실패 시 가상 영상
    
    def overlay_drone_info(self, frame):
        """실제 영상에 드론 정보 오버레이"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        cv2.putText(frame, f"Drone: {self.drone_id}", (20, 30), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
        cv2.putText(frame, timestamp, (20, 60), 
                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
    
    def compress_frame(self, frame, quality=85):
        """JPEG 압축으로 프레임 크기 줄이기"""
        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), quality]
        result, encoded_frame = cv2.imencode('.jpg', frame, encode_param)
        return encoded_frame
    
    def send_video_frame(self, frame):
        """UDP로 프레임 전송"""
        try:
            # 프레임 압축
            encoded_frame = self.compress_frame(frame)
            
            # 데이터 직렬화
            data = pickle.dumps(encoded_frame)
            
            # 패킷 분할 (큰 프레임을 위해)
            packet_size = 4096
            packets = [data[i:i+packet_size] for i in range(0, len(data), packet_size)]
            
            # 패킷 헤더 추가 및 전송
            for i, packet in enumerate(packets):
                # 헤더: 패킷번호/총패킷수/드론ID
                header = f"{i:04d}{len(packets):04d}{self.drone_id:10s}"
                packet_with_header = header.encode() + packet
                self.video_socket.sendto(packet_with_header, (SERVER_IP, VIDEO_PORT))
            
            return True
        except Exception as e:
            print(f"[ERROR] 영상 전송 실패: {e}")
            return False
    
    def send_telemetry(self):
        """텔레메트리 데이터 전송"""
        telemetry_data = {
            'drone_id': self.drone_id,
            'position': self.position,
            'battery': self.battery,
            'is_flying': self.is_flying,
            'frame_count': self.frame_count,
            'timestamp': time.time()
        }
        
        try:
            data = pickle.dumps(telemetry_data)
            self.telemetry_socket.sendto(data, (SERVER_IP, TELEMETRY_PORT))
        except Exception as e:
            print(f"[ERROR] 텔레메트리 전송 실패: {e}")
    
    def update_drone_state(self, x=0.0, y=0.0, z=0.0, battery=None, flying=None):
        """드론 상태 업데이트"""
        self.position['x'] = x
        self.position['y'] = y
        self.position['z'] = z
        
        if battery is not None:
            self.battery = max(0.0, min(100.0, battery))
        
        if flying is not None:
            self.is_flying = flying
    
    def start_streaming(self, duration=None):
        """영상 스트리밍 시작"""
        self.is_streaming = True
        print(f"[DRONE {self.drone_id}] 영상 스트리밍 시작...")
        
        start_time = time.time()
        telemetry_interval = 1.0  # 텔레메트리 전송 간격 (초)
        last_telemetry_time = time.time()
        
        try:
            while self.is_streaming:
                # 영상 프레임 캡처 및 전송
                frame = self.capture_frame()
                self.send_video_frame(frame)
                
                # 주기적으로 텔레메트리 전송
                current_time = time.time()
                if current_time - last_telemetry_time >= telemetry_interval:
                    self.send_telemetry()
                    last_telemetry_time = current_time
                    
                    # 배터리 감소 시뮬레이션
                    if self.is_flying:
                        self.battery = max(0, self.battery - 0.1)
                
                # 지연 시간 조절
                time.sleep(1.0 / FPS)
                
                # 지정된 시간만 스트리밍
                if duration and (time.time() - start_time) > duration:
                    break
                    
        except KeyboardInterrupt:
            print(f"\n[DRONE {self.drone_id}] 스트리밍 중단됨")
        finally:
            self.stop_streaming()
    
    def stop_streaming(self):
        """영상 스트리밍 중지"""
        self.is_streaming = False
        if self.cap:
            self.cap.release()
        print(f"[DRONE {self.drone_id}] 영상 스트리밍 중지")
    
    def run_simulation(self):
        """드론 시뮬레이션 실행 (테스트용)"""
        print(f"[DRONE {self.drone_id}] 시뮬레이션 모드 시작")
        
        # 별도 스레드로 스트리밍 시작
        stream_thread = threading.Thread(target=self.start_streaming)
        stream_thread.daemon = True
        stream_thread.start()
        
        # 시뮬레이션 루프
        try:
            x, y, z = 0.0, 0.0, 0.0
            self.is_flying = True
            
            while True:
                # 원형 경로로 비행 시뮬레이션
                t = time.time()
                x = 50.0 * np.sin(t * 0.5)
                y = 50.0 * np.cos(t * 0.5)
                z = 20.0 + 5.0 * np.sin(t * 0.2)
                
                self.update_drone_state(x, y, z)
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            self.stop_streaming()
            print(f"\n[DRONE {self.drone_id}] 시뮬레이션 종료")

# 드론 실행 (테스트용)
if __name__ == "__main__":
    import sys
    
    drone_id = sys.argv[1] if len(sys.argv) > 1 else "DRONE_001"
    drone = DroneVideoSender(drone_id=drone_id, use_virtual_camera=True)
    
    # 시뮬레이션 모드 실행
    drone.run_simulation()
```

### **1.3 서버 측 - 영상 수신 프로그램**

```python
# server_video_receiver.py
import cv2
import socket
import pickle
import struct
import threading
import time
import numpy as np
from collections import defaultdict
from config import *

class VideoServer:
    def __init__(self):
        self.clients = {}  # 연결된 드론들
        self.is_running = False
        
        # 소켓 설정
        self.video_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.video_socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, BUFFER_SIZE)
        self.video_socket.bind((SERVER_IP, VIDEO_PORT))
        
        self.telemetry_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.telemetry_socket.bind((SERVER_IP, TELEMETRY_PORT))
        
        # 패킷 재조립을 위한 버퍼
        self.packet_buffers = defaultdict(dict)
        
        print(f"[SERVER] 영상 서버 시작: {SERVER_IP}:{VIDEO_PORT}")
        print(f"[SERVER] 텔레메트리 포트: {TELEMETRY_PORT}")
    
    def process_video_packet(self, data, addr):
        """비디오 패킷 처리"""
        try:
            # 헤더 파싱 (패킷번호 4자리, 총패킷수 4자리, 드론ID 10자리)
            header = data[:18].decode()
            packet_num = int(header[:4])
            total_packets = int(header[4:8])
            drone_id = header[8:].strip()
            
            # 패킷 데이터
            packet_data = data[18:]
            
            # 패킷 버퍼에 저장
            if drone_id not in self.packet_buffers:
                self.packet_buffers[drone_id] = {}
            
            self.packet_buffers[drone_id][packet_num] = packet_data
            
            # 모든 패킷 도착 시 프레임 재구성
            if len(self.packet_buffers[drone_id]) == total_packets:
                # 패킷 정렬 및 결합
                packets = [self.packet_buffers[drone_id][i] for i in range(total_packets)]
                combined_data = b''.join(packets)
                
                # 프레임 디코딩
                encoded_frame = pickle.loads(combined_data)
                frame = cv2.imdecode(encoded_frame, cv2.IMREAD_COLOR)
                
                # 버퍼 클리어
                del self.packet_buffers[drone_id]
                
                # 클라이언트 정보 업데이트
                if drone_id not in self.clients:
                    self.clients[drone_id] = {
                        'addr': addr,
                        'last_seen': time.time(),
                        'frame_count': 0
                    }
                
                self.clients[drone_id]['last_seen'] = time.time()
                self.clients[drone_id]['frame_count'] += 1
                
                return drone_id, frame
            
        except Exception as e:
            print(f"[ERROR] 패킷 처리 실패: {e}")
        
        return None, None
    
    def receive_video_stream(self):
        """비디오 스트림 수신"""
        print("[SERVER] 비디오 스트림 수신 대기중...")
        
        while self.is_running:
            try:
                data, addr = self.video_socket.recvfrom(BUFFER_SIZE)
                
                drone_id, frame = self.process_video_packet(data, addr)
                
                if frame is not None:
                    # 영상 표시
                    window_name = f"Drone: {drone_id}"
                    cv2.imshow(window_name, frame)
                    
                    # 'q' 키로 종료
                    if cv2.waitKey(1) & 0xFF == ord('q'):
                        break
                        
            except socket.timeout:
                continue
            except Exception as e:
                print(f"[ERROR] 수신 오류: {e}")
    
    def receive_telemetry(self):
        """텔레메트리 데이터 수신"""
        print("[SERVER] 텔레메트리 수신 대기중...")
        
        while self.is_running:
            try:
                data, addr = self.telemetry_socket.recvfrom(BUFFER_SIZE)
                telemetry = pickle.loads(data)
                
                drone_id = telemetry['drone_id']
                print(f"\n[TELEMETRY] 드론: {drone_id}")
                print(f"  위치: ({telemetry['position']['x']:.1f}, "
                      f"{telemetry['position']['y']:.1f}, "
                      f"{telemetry['position']['z']:.1f})")
                print(f"  배터리: {telemetry['battery']:.1f}%")
                print(f"  상태: {'비행중' if telemetry['is_flying'] else '지상'}")
                print(f"  프레임: {telemetry['frame_count']}")
                
                # 클라이언트 정보 업데이트
                if drone_id not in self.clients:
                    self.clients[drone_id] = {'addr': addr}
                
                self.clients[drone_id].update({
                    'telemetry': telemetry,
                    'last_telemetry': time.time()
                })
                
            except socket.timeout:
                continue
            except Exception as e:
                print(f"[ERROR] 텔레메트리 수신 오류: {e}")
    
    def monitor_clients(self):
        """클라이언트 상태 모니터링"""
        while self.is_running:
            print("\n" + "="*50)
            print("연결된 드론 목록:")
            print("="*50)
            
            current_time = time.time()
            inactive_drones = []
            
            for drone_id, info in self.clients.items():
                last_seen = info.get('last_seen', 0)
                time_diff = current_time - last_seen
                
                if time_diff < 10:  # 10초 이내 활동 있음
                    status = "ACTIVE"
                    frame_rate = info.get('frame_count', 0) / max(time_diff, 1)
                    
                    print(f"{drone_id}: {status}")
                    print(f"  프레임률: {frame_rate:.1f} FPS")
                    
                    if 'telemetry' in info:
                        tel = info['telemetry']
                        print(f"  배터리: {tel['battery']:.1f}%")
                        print(f"  위치: ({tel['position']['x']:.1f}, "
                              f"{tel['position']['y']:.1f}, {tel['position']['z']:.1f})")
                else:
                    status = "INACTIVE"
                    inactive_drones.append(drone_id)
                    print(f"{drone_id}: {status}")
            
            # 비활성 드론 제거
            for drone_id in inactive_drones:
                del self.clients[drone_id]
            
            time.sleep(5)  # 5초마다 업데이트
    
    def start(self):
        """서버 시작"""
        self.is_running = True
        
        # 스레드 시작
        video_thread = threading.Thread(target=self.receive_video_stream)
        telemetry_thread = threading.Thread(target=self.receive_telemetry)
        monitor_thread = threading.Thread(target=self.monitor_clients)
        
        video_thread.daemon = True
        telemetry_thread.daemon = True
        monitor_thread.daemon = True
        
        video_thread.start()
        telemetry_thread.start()
        monitor_thread.start()
        
        print("[SERVER] 서버가 모든 스레드를 시작했습니다.")
        print("[SERVER] 종료하려면 Ctrl+C를 누르세요.")
        
        try:
            # 메인 스레드 대기
            while self.is_running:
                time.sleep(1)
        except KeyboardInterrupt:
            self.stop()
    
    def stop(self):
        """서버 중지"""
        self.is_running = False
        cv2.destroyAllWindows()
        print("\n[SERVER] 서버 종료")

# 서버 실행
if __name__ == "__main__":
    server = VideoServer()
    server.start()
```

---

## **2. MAVLink 프로토콜 기반 통신 (고급/원거리)**

```python
# mavlink_communication.py
"""
MAVLink (Micro Air Vehicle Link) 프로토콜을 이용한 드론 통신
- 실제 드론과의 표준 통신 프로토콜
- 원거리 통신 가능 (수십 km)
- 다양한 메시지 타입 지원
"""

import time
import threading
from pymavlink import mavutil

class MavlinkDrone:
    def __init__(self, connection_string="udp:127.0.0.1:14550"):
        """
        connection_string:
        - "udp:IP:PORT" : UDP 통신
        - "tcp:IP:PORT" : TCP 통신  
        - "serial:/dev/ttyUSB0:57600" : 시리얼 통신
        """
        self.connection_string = connection_string
        self.master = None
        self.is_connected = False
        
    def connect(self):
        """MAVLink 연결"""
        try:
            print(f"[MAVLINK] 연결 시도: {self.connection_string}")
            self.master = mavutil.mavlink_connection(self.connection_string)
            
            # 하트비트 대기 (연결 확인)
            self.master.wait_heartbeat()
            print("[MAVLINK] 연결 성공!")
            
            self.is_connected = True
            return True
            
        except Exception as e:
            print(f"[MAVLINK] 연결 실패: {e}")
            return False
    
    def send_video_stream(self, frame_data):
        """MAVLink로 영상 데이터 전송 (DATA_TRANSMISSION_HANDSHAKE 메시지 사용)"""
        if not self.is_connected:
            return False
        
        try:
            # 영상 데이터를 청크로 분할
            chunk_size = 253  # MAVLink 패킷 최대 크기
            total_size = len(frame_data)
            
            for i in range(0, total_size, chunk_size):
                chunk = frame_data[i:i+chunk_size]
                
                # DATA_TRANSMISSION_HANDSHAKE 메시지 전송
                self.master.mav.data_transmission_handshake_send(
                    mavutil.mavlink.MAV_DATA_STREAM_VIDEO,  # 스트림 타입: 비디오
                    len(chunk),  # 데이터 크기
                    total_size,  # 전체 크기
                    i,  # 패킷 번호
                    total_size // chunk_size + 1,  # 총 패킷 수
                )
                
                # 실제 데이터 전송 (encapsulated_data 메시지 사용)
                self.master.mav.encapsulated_data_send(
                    i,  # 시퀀스 번호
                    chunk
                )
                
                time.sleep(0.001)  # 작은 지연
            
            return True
            
        except Exception as e:
            print(f"[MAVLINK] 영상 전송 실패: {e}")
            return False
    
    def send_telemetry(self, position, attitude, battery):
        """텔레메트리 데이터 전송"""
        if not self.is_connected:
            return
        
        try:
            # GLOBAL_POSITION_INT 메시지
            self.master.mav.global_position_int_send(
                int(time.time() * 1000),  # 타임스탬프
                int(position['lat'] * 1e7),  # 위도 (degrees * 1e7)
                int(position['lon'] * 1e7),  # 경도
                int(position['alt'] * 1000),  # 고도 (mm)
                int(position['relative_alt'] * 1000),  # 상대 고도
                int(attitude['vx'] * 100),  # X 속도 (cm/s)
                int(attitude['vy'] * 100),  # Y 속도
                int(attitude['vz'] * 100),  # Z 속도
                int(attitude['heading'] * 100)  # 방향 (centidegrees)
            )
            
            # BATTERY_STATUS 메시지
            self.master.mav.battery_status_send(
                0,  # 배터리 ID
                int(battery * 100),  # 배터리 잔량 (0-100%)
                0,  # 전류 (cA)
                0,  # 누전 전류량 (mAh)
                0,  # 에너지 소비 (hJ)
                0,  # 배터리 온도 (cdegC)
                [0] * 10,  # 전압 (mV)
                0,  # 전류 (cA)
                0  # 배터리 남은 시간
            )
            
        except Exception as e:
            print(f"[MAVLINK] 텔레메트리 전송 실패: {e}")
    
    def receive_messages(self):
        """MAVLink 메시지 수신"""
        print("[MAVLINK] 메시지 수신 대기중...")
        
        while self.is_connected:
            try:
                msg = self.master.recv_match(blocking=True, timeout=1.0)
                if msg:
                    self.handle_message(msg)
                    
            except Exception as e:
                print(f"[MAVLINK] 메시지 수신 오류: {e}")
    
    def handle_message(self, msg):
        """수신된 메시지 처리"""
        msg_type = msg.get_type()
        
        if msg_type == "HEARTBEAT":
            print(f"[MAVLINK] 하트비트 수신: 시스템 상태: {msg.system_status}")
            
        elif msg_type == "GLOBAL_POSITION_INT":
            lat = msg.lat / 1e7
            lon = msg.lon / 1e7
            alt = msg.alt / 1000
            print(f"[MAVLINK] 위치: ({lat:.6f}, {lon:.6f}, {alt:.1f}m)")
            
        elif msg_type == "ENCAPSULATED_DATA":
            # 영상 데이터 수신
            print(f"[MAVLINK] 영상 데이터 패킷 수신: 시퀀스 {msg.seqnr}")
            
        elif msg_type == "DATA_TRANSMISSION_HANDSHAKE":
            print(f"[MAVLINK] 데이터 전송 시작: 타입 {msg.type}, 크기 {msg.size}")
```

---

## **3. 실행 방법**

### **방법 1: Wi-Fi UDP 통신 (로컬 테스트)**

**터미널 1 - 서버 실행:**
```bash
python server_video_receiver.py
```

**터미널 2 - 드론1 실행:**
```bash
python drone_video_sender.py DRONE_001
```

**터미널 3 - 드론2 실행:**
```bash
python drone_video_sender.py DRONE_002
```

### **방법 2: MAVLink 시뮬레이션**

**MAVProxy 설치:**
```bash
# MAVLink 시뮬레이션 도구 설치
pip install pymavlink
pip install mavproxy

# MAVProxy로 시뮬레이션 시작
mavproxy.py --master=udp:127.0.0.1:14550 --out=udp:127.0.0.1:14551
```

---

## **4. 통신 방식 비교**

| 통신 방식 | 거리 | 속도 | 지연 | 구현 난이도 | 용도 |
|-----------|------|------|------|-------------|------|
| **Wi-Fi UDP** | 100m 내외 | 10-100 Mbps | 낮음 | 쉬움 | 실내/근거리 테스트 |
| **MAVLink** | 수십 km | 1-10 Mbps | 중간 | 어려움 | 실제 드론 통신 |
| **4G/5G LTE** | 전국 | 10-1000 Mbps | 높음 | 중간 | 원거리 실시간 |
| **LoRa** | 10km+ | 0.3-50 kbps | 높음 | 중간 | 텔레메트리만 |

---

## **5. 추가 기능 제안**

1. **영상 압축 알고리즘 선택**
   - MJPEG: 단순, 낮은 CPU 사용
   - H.264: 고효율, 높은 CPU 사용
   - WebRTC: 실시간 스트리밍 최적화

2. **QoS (Quality of Service) 구현**
   - 네트워크 상태에 따른 화질 조정
   - 패킷 손실 복구 메커니즘

3. **다중 드론 관리**
   - 드론별 영상 분리 표시
   - 통합 지도에 위치 표시

4. **영상 분석 기능**
   - 객체 감지 (OpenCV/YOLO)
   - 비정상 상황 탐지
   - 자동 추적 기능

이 시스템은 실제 드론 영상 관제 시스템의 핵심 요소를 포함하고 있으며, 통신 방식을 변경하여 다양한 환경에 적용할 수 있습니다.
