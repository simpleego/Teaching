#  추상클래스, 내부클래스, 인터페이스
> Java Swing 기반 계산기를 구현하면서 위의 클래스를 이용하여 개념을 익힌다.

---

## 1. 설계 개요 (학습 포인트)

| 구분             | 적용 내용                |
| -------------- | -------------------- |
| 상속             | `JFrame` 상속          |
| 추상 클래스         | 연산 공통 로직 정의          |
| 인터페이스          | 연산 기능 규약             |
| 메서드 오버라이딩      | 연산 구현                |
| 메서드 오버로딩       | 입력 방식 차이             |
| 이벤트 처리(독립 클래스) | 덧셈                   |
| 이벤트 처리(내부 클래스) | 뺄셈                   |
| 이벤트 처리(익명 클래스) | 곱셈                   |
| 이벤트 처리(Lambda) | 나눗셈                  |
| 다형성            | 연산 객체를 인터페이스 타입으로 사용 |

---

## 2. 인터페이스 (연산 규약)

```java
public interface Calculator {
    double calculate(double a, double b);
}
```

---

## 3. 추상 클래스 (공통 기능 + 오버로딩)

```java
public abstract class AbstractCalculator implements Calculator {

    // 공통 출력 포맷
    protected String format(double result) {
        return "결과: " + result;
    }

    // 메서드 오버로딩
    public double calculate(int a, int b) {
        return calculate((double) a, (double) b);
    }
}
```

---

## 4. 연산 클래스들 (메서드 오버라이딩)

```java
public class AddCalculator extends AbstractCalculator {
    @Override
    public double calculate(double a, double b) {
        return a + b;
    }
}

public class SubCalculator extends AbstractCalculator {
    @Override
    public double calculate(double a, double b) {
        return a - b;
    }
}

public class MulCalculator extends AbstractCalculator {
    @Override
    public double calculate(double a, double b) {
        return a * b;
    }
}

public class DivCalculator extends AbstractCalculator {
    @Override
    public double calculate(double a, double b) {
        if (b == 0) throw new ArithmeticException("0으로 나눌 수 없습니다.");
        return a / b;
    }
}
```

---

## 5. 이벤트 처리 – 독립 클래스 (덧셈)

```java
import java.awt.event.*;

public class AddActionListener implements ActionListener {

    private CalculatorFrame frame;

    public AddActionListener(CalculatorFrame frame) {
        this.frame = frame;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        frame.execute(new AddCalculator());
    }
}
```

---

## 6. 메인 UI 클래스 (상속 + 내부/익명 클래스)

```java
import javax.swing.*;
import java.awt.*;

public class CalculatorFrame extends JFrame {

    private JTextField tf1 = new JTextField(10);
    private JTextField tf2 = new JTextField(10);
    private JLabel resultLabel = new JLabel("결과:");

    public CalculatorFrame() {
        setTitle("OOP Calculator");
        setSize(400, 200);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setLayout(new FlowLayout());

        JButton btnAdd = new JButton("덧셈");
        JButton btnSub = new JButton("뺄셈");
        JButton btnMul = new JButton("곱셈");
        JButton btnDiv = new JButton("나눗셈");

        add(tf1);
        add(tf2);
        add(btnAdd);
        add(btnSub);
        add(btnMul);
        add(btnDiv);
        add(resultLabel);

        // 1) 독립 클래스
        btnAdd.addActionListener(new AddActionListener(this));

        // 2) 내부 클래스
        btnSub.addActionListener(new SubActionListener());

        // 3) 익명 클래스
        btnMul.addActionListener(e -> execute(new MulCalculator()));

        // 4) 람다식 (익명 클래스의 축약)
        btnDiv.addActionListener(e -> execute(new DivCalculator()));
    }

    // 내부 클래스
    private class SubActionListener implements java.awt.event.ActionListener {
        @Override
        public void actionPerformed(java.awt.event.ActionEvent e) {
            execute(new SubCalculator());
        }
    }

    // 공통 실행 메서드 (다형성)
    public void execute(Calculator calculator) {
        try {
            double a = Double.parseDouble(tf1.getText());
            double b = Double.parseDouble(tf2.getText());
            double result = calculator.calculate(a, b);
            resultLabel.setText("결과: " + result);
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this, ex.getMessage());
        }
    }

    public static void main(String[] args) {
        new CalculatorFrame().setVisible(true);
    }
}
```

---

## 7. 이 예제로 학습 가능한 핵심 개념 정리

* **상속**: `CalculatorFrame extends JFrame`
* **추상화**: `AbstractCalculator`
* **인터페이스 기반 다형성**: `Calculator` 타입으로 실행
* **메서드 오버라이딩**: 각 연산 클래스
* **메서드 오버로딩**: `calculate(int, int)`
* **이벤트 처리 방식 비교**

  * 독립 클래스
  * 내부 클래스
  * 익명 클래스
  * 람다식
* **UI + 로직 분리 구조**

---

## 8. 확장 과제 (교육용으로 추천)

* 연산 이력 `ArrayList`로 관리
* MVC 패턴으로 구조 리팩토링
* 전략 패턴으로 연산 구조 재구성
* 입력값 검증 로직 분리

---
